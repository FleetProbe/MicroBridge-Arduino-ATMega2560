   1               		.file	"stk500boot.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	sendchar:
  13               	.LFB21:
  14               		.file 1 "stk500boot.c"
   1:stk500boot.c  **** /*****************************************************************************
   2:stk500boot.c  ****  Title:     STK500v2 compatible bootloader
   3:stk500boot.c  ****  Modified for Wiring board ATMega128-16MHz
   4:stk500boot.c  ****  Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   5:stk500boot.c  ****  File:      $Id: stk500boot.c,v 1.11 2006/06/25 12:39:17 peter Exp $
   6:stk500boot.c  ****  Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   7:stk500boot.c  ****  Hardware:  All AVRs with bootloader support, tested with ATmega8
   8:stk500boot.c  ****  License:   GNU General Public License
   9:stk500boot.c  **** 
  10:stk500boot.c  ****  Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  11:stk500boot.c  ****  Date:      17 October 2007
  12:stk500boot.c  ****  Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte r
  13:stk500boot.c  ****  Compiler:  WINAVR20060421
  14:stk500boot.c  ****  Description: add timeout feature like previous Wiring bootloader
  15:stk500boot.c  **** 
  16:stk500boot.c  ****  DESCRIPTION:
  17:stk500boot.c  ****  This program allows an AVR with bootloader capabilities to
  18:stk500boot.c  ****  read/write its own Flash/EEprom. To enter Programming mode
  19:stk500boot.c  ****  an input pin is checked. If this pin is pulled low, programming mode
  20:stk500boot.c  ****  is entered. If not, normal execution is done from $0000
  21:stk500boot.c  ****  "reset" vector in Application area.
  22:stk500boot.c  ****  Size fits into a 1024 word bootloader section
  23:stk500boot.c  ****  when compiled with avr-gcc 4.1
  24:stk500boot.c  ****  (direct replace on Wiring Board without fuse setting changed)
  25:stk500boot.c  **** 
  26:stk500boot.c  ****  USAGE:
  27:stk500boot.c  ****  - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  28:stk500boot.c  ****  - Set baud rate below (AVRISP only works with 115200 bps)
  29:stk500boot.c  ****  - compile/link the bootloader with the supplied Makefile
  30:stk500boot.c  ****  - program the "Boot Flash section size" (BOOTSZ fuses),
  31:stk500boot.c  ****  for boot-size 1024 words:  program BOOTSZ01
  32:stk500boot.c  ****  - enable the BOOT Reset Vector (program BOOTRST)
  33:stk500boot.c  ****  - Upload the hex file to the AVR using any ISP programmer
  34:stk500boot.c  ****  - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  35:stk500boot.c  ****  - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  36:stk500boot.c  ****  - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  37:stk500boot.c  ****  - AVRISP will detect the bootloader
  38:stk500boot.c  ****  - Program your application FLASH file and optional EEPROM file using AVRISP
  39:stk500boot.c  **** 
  40:stk500boot.c  ****  Note:
  41:stk500boot.c  ****  Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  42:stk500boot.c  ****  is not implemented, due to AVRStudio limitations.
  43:stk500boot.c  ****  Flash is always erased before programming.
  44:stk500boot.c  **** 
  45:stk500boot.c  ****  AVRdude:
  46:stk500boot.c  ****  Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  47:stk500boot.c  ****  Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  48:stk500boot.c  ****  Read Fuse Bits and Read/Write Lock Bits is not supported
  49:stk500boot.c  **** 
  50:stk500boot.c  ****  NOTES:
  51:stk500boot.c  ****  Based on Atmel Application Note AVR109 - Self-programming
  52:stk500boot.c  ****  Based on Atmel Application Note AVR068 - STK500v2 Protocol
  53:stk500boot.c  **** 
  54:stk500boot.c  ****  LICENSE:
  55:stk500boot.c  ****  Copyright (C) 2006 Peter Fleury
  56:stk500boot.c  **** 
  57:stk500boot.c  ****  This program is free software; you can redistribute it and/or modify
  58:stk500boot.c  ****  it under the terms of the GNU General Public License as published by
  59:stk500boot.c  ****  the Free Software Foundation; either version 2 of the License, or
  60:stk500boot.c  ****  any later version.
  61:stk500boot.c  **** 
  62:stk500boot.c  ****  This program is distributed in the hope that it will be useful,
  63:stk500boot.c  ****  but WITHOUT ANY WARRANTY; without even the implied warranty of
  64:stk500boot.c  ****  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  65:stk500boot.c  ****  GNU General Public License for more details.
  66:stk500boot.c  **** 
  67:stk500boot.c  ****  *****************************************************************************/
  68:stk500boot.c  **** 
  69:stk500boot.c  **** //************************************************************************
  70:stk500boot.c  **** //*	Edit History
  71:stk500boot.c  **** //************************************************************************
  72:stk500boot.c  **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  73:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  74:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  75:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  76:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Adding monitor code
  77:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  78:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added EEPROM test
  79:stk500boot.c  **** //*	Jul 29,	2010	<MLS> Added recchar_timeout for timing out on bootloading
  80:stk500boot.c  **** //*	Aug 23,	2010	<MLS> Added support for atmega2561
  81:stk500boot.c  **** //*	Aug 26,	2010	<MLS> Removed support for BOOT_BY_SWITCH
  82:stk500boot.c  **** //*	Sep  8,	2010	<MLS> Added support for atmega16
  83:stk500boot.c  **** //*	Nov  9,	2010	<MLS> Issue 392:Fixed bug that 3 !!! in code would cause it to jump to monitor
  84:stk500boot.c  **** //*	Jun 24,	2011	<MLS> Removed analogRead (was not used)
  85:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 181: added watch dog timmer support
  86:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 505:  bootloader is comparing the seqNum to 1 or the current sequence 
  87:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: CMD_CHIP_ERASE_ISP now returns STATUS_CMD_FAILED instead of STATU
  88:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: Write EEPROM now does something (NOT TESTED)
  89:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 544: stk500v2 bootloader doesn't support reading fuses
  90:stk500boot.c  **** //************************************************************************
  91:stk500boot.c  **** //************************************************************************
  92:stk500boot.c  **** //*	these are used to test issues
  93:stk500boot.c  **** //*	http://code.google.com/p/arduino/issues/detail?id=505
  94:stk500boot.c  **** //*	Reported by mark.stubbs, Mar 14, 2011
  95:stk500boot.c  **** //*	The STK500V2 bootloader is comparing the seqNum to 1 or the current sequence 
  96:stk500boot.c  **** //*	(IE: Requiring the sequence to be 1 or match seqNum before continuing).  
  97:stk500boot.c  **** //*	The correct behavior is for the STK500V2 to accept the PC's sequence number, and echo it back f
  98:stk500boot.c  **** #define	_FIX_ISSUE_505_
  99:stk500boot.c  **** //************************************************************************
 100:stk500boot.c  **** //*	Issue 181: added watch dog timmer support
 101:stk500boot.c  **** #define	_FIX_ISSUE_181_
 102:stk500boot.c  **** 
 103:stk500boot.c  **** #include	<inttypes.h>
 104:stk500boot.c  **** #include	<avr/io.h>
 105:stk500boot.c  **** #include	<avr/interrupt.h>
 106:stk500boot.c  **** #include	<avr/boot.h>
 107:stk500boot.c  **** #include	<avr/pgmspace.h>
 108:stk500boot.c  **** #include	<util/delay.h>
 109:stk500boot.c  **** #include	<avr/eeprom.h>
 110:stk500boot.c  **** #include	<avr/common.h>
 111:stk500boot.c  **** #include	<stdlib.h>
 112:stk500boot.c  **** #include	"command.h"
 113:stk500boot.c  **** 
 114:stk500boot.c  **** #include <string.h>
 115:stk500boot.c  **** #include "pff.h"
 116:stk500boot.c  **** 
 117:stk500boot.c  **** void flash_erase(DWORD); /* Erase a flash page (asmfunc.S) */
 118:stk500boot.c  **** void flash_write(DWORD, const BYTE*); /* Program a flash page (asmfunc.S) */
 119:stk500boot.c  **** 
 120:stk500boot.c  **** #define BLINK_LED_WHILE_WAITING
 121:stk500boot.c  **** //#define _DEBUG_WITH_LEDS_
 122:stk500boot.c  **** //#define _DEBUG_SERIAL_
 123:stk500boot.c  **** 
 124:stk500boot.c  **** #if defined(_MEGA_BOARD_) || defined(_BOARD_AMBER128_) || defined(__AVR_ATmega1280__) || defined(__
 125:stk500boot.c  **** 	|| defined(__AVR_ATmega2561__) || defined(__AVR_ATmega1284P__) || defined(ENABLE_MONITOR)
 126:stk500boot.c  **** #undef		ENABLE_MONITOR
 127:stk500boot.c  **** #define		ENABLE_MONITOR
 128:stk500boot.c  **** #endif
 129:stk500boot.c  **** 
 130:stk500boot.c  **** #ifndef EEWE
 131:stk500boot.c  **** #define EEWE    1
 132:stk500boot.c  **** #endif
 133:stk500boot.c  **** #ifndef EEMWE
 134:stk500boot.c  **** #define EEMWE   2
 135:stk500boot.c  **** #endif
 136:stk500boot.c  **** 
 137:stk500boot.c  **** //#define	_DEBUG_SERIAL_
 138:stk500boot.c  **** //#define	_DEBUG_WITH_LEDS_
 139:stk500boot.c  **** 
 140:stk500boot.c  **** /*
 141:stk500boot.c  ****  * Uncomment the following lines to save code space
 142:stk500boot.c  ****  */
 143:stk500boot.c  **** //#define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT		// disable program lock bits
 144:stk500boot.c  **** //#define	REMOVE_BOOTLOADER_LED				// no LED to show active bootloader
 145:stk500boot.c  **** //#define	REMOVE_CMD_SPI_MULTI				// disable processing of SPI_MULTI commands, Remark this line for
 146:stk500boot.c  **** //
 147:stk500boot.c  **** //************************************************************************
 148:stk500boot.c  **** //*	LED on pin "PROGLED_PIN" on port "PROGLED_PORT"
 149:stk500boot.c  **** //*	indicates that bootloader is active
 150:stk500boot.c  **** //*	PG2 -> LED on Wiring board
 151:stk500boot.c  **** //************************************************************************
 152:stk500boot.c  **** #define		BLINK_LED_WHILE_WAITING
 153:stk500boot.c  **** 
 154:stk500boot.c  **** 
 155:stk500boot.c  **** #define SPI_DDRA DDRA
 156:stk500boot.c  **** #define SPI_PORTA PORTA
 157:stk500boot.c  **** #define SPI_DDRB DDRB
 158:stk500boot.c  **** #define SPI_PORTB PORTB
 159:stk500boot.c  **** #define SPI_DDRE DDRE
 160:stk500boot.c  **** #define SPI_PORTE PORTE
 161:stk500boot.c  **** 
 162:stk500boot.c  **** #define SCK PINB1 //Pin 52
 163:stk500boot.c  **** #define MISO PINB3 //Pin 50
 164:stk500boot.c  **** #define MOSI PINB2 //Pin 51
 165:stk500boot.c  **** #define SS PINE6 //Pin 22
 166:stk500boot.c  **** #define SS_MASTER PINB0 //Pin 53
 167:stk500boot.c  **** #define LED1 PINA0
 168:stk500boot.c  **** #define LED2 PINA1
 169:stk500boot.c  **** #define LED3 PINA2
 170:stk500boot.c  **** 		
 171:stk500boot.c  **** 
 172:stk500boot.c  **** #define LED1_LOW() SPI_PORTA &= ~(_BV(LED1))
 173:stk500boot.c  **** #define LED1_HIGH() SPI_PORTA |= _BV(LED1)
 174:stk500boot.c  **** #define LED2_LOW() SPI_PORTA &= ~(_BV(LED2))
 175:stk500boot.c  **** #define LED2_HIGH() SPI_PORTA |= _BV(LED2)
 176:stk500boot.c  **** #define LED3_LOW() SPI_PORTA &= ~(_BV(LED3))
 177:stk500boot.c  **** #define LED3_HIGH() SPI_PORTA |= _BV(LED3)
 178:stk500boot.c  **** 
 179:stk500boot.c  **** 
 180:stk500boot.c  **** #define SS_LOW() SPI_PORTE &= ~(_BV(SS))
 181:stk500boot.c  **** #define SS_HIGH() SPI_PORTE |= _BV(SS)
 182:stk500boot.c  **** #define SS_MASTER_LOW() SPI_PORTB &= ~_BV(SS_MASTER)
 183:stk500boot.c  **** #define SS_MASTER_HIGH() SPI_PORTB |= _BV(SS_MASTER)
 184:stk500boot.c  **** 
 185:stk500boot.c  **** /*
 186:stk500boot.c  ****  * define CPU frequency in Mhz here if not defined in Makefile
 187:stk500boot.c  ****  */
 188:stk500boot.c  **** #ifndef F_CPU
 189:stk500boot.c  **** #define F_CPU 16000000UL
 190:stk500boot.c  **** #endif
 191:stk500boot.c  **** 
 192:stk500boot.c  **** #define	_BLINK_LOOP_COUNT_	(F_CPU / 2250)
 193:stk500boot.c  **** /*
 194:stk500boot.c  ****  * UART Baudrate, AVRStudio AVRISP only accepts 115200 bps
 195:stk500boot.c  ****  */
 196:stk500boot.c  **** 
 197:stk500boot.c  **** #ifndef BAUDRATE
 198:stk500boot.c  **** #define BAUDRATE 115200
 199:stk500boot.c  **** #endif
 200:stk500boot.c  **** 
 201:stk500boot.c  **** /*
 202:stk500boot.c  ****  *  Enable (1) or disable (0) USART double speed operation
 203:stk500boot.c  ****  */
 204:stk500boot.c  **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
 205:stk500boot.c  **** #if defined (__AVR_ATmega32__)
 206:stk500boot.c  **** #define UART_BAUDRATE_DOUBLE_SPEED 0
 207:stk500boot.c  **** #else
 208:stk500boot.c  **** #define UART_BAUDRATE_DOUBLE_SPEED 1
 209:stk500boot.c  **** #endif
 210:stk500boot.c  **** #endif
 211:stk500boot.c  **** 
 212:stk500boot.c  **** /*
 213:stk500boot.c  ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
 214:stk500boot.c  ****  */
 215:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
 216:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
 217:stk500boot.c  **** #define CONFIG_PARAM_HW_VER				0x0F
 218:stk500boot.c  **** #define CONFIG_PARAM_SW_MAJOR			2
 219:stk500boot.c  **** #define CONFIG_PARAM_SW_MINOR			0x0A
 220:stk500boot.c  **** 
 221:stk500boot.c  **** /*
 222:stk500boot.c  ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 223:stk500boot.c  ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 224:stk500boot.c  ****  */
 225:stk500boot.c  **** //#define BOOTSIZE 1024
 226:stk500boot.c  **** #if FLASHEND > 0x0F000
 227:stk500boot.c  **** #define BOOTSIZE 8192
 228:stk500boot.c  **** #else
 229:stk500boot.c  **** #define BOOTSIZE 2048
 230:stk500boot.c  **** #endif
 231:stk500boot.c  **** 
 232:stk500boot.c  **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 233:stk500boot.c  **** 
 234:stk500boot.c  **** /*
 235:stk500boot.c  ****  * Signature bytes are not available in avr-gcc io_xxx.h
 236:stk500boot.c  ****  */
 237:stk500boot.c  **** #if defined (__AVR_ATmega8__)
 238:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9307
 239:stk500boot.c  **** #elif defined (__AVR_ATmega16__)
 240:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9403
 241:stk500boot.c  **** #elif defined (__AVR_ATmega32__)
 242:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9502
 243:stk500boot.c  **** #elif defined (__AVR_ATmega8515__)
 244:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9306
 245:stk500boot.c  **** #elif defined (__AVR_ATmega8535__)
 246:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9308
 247:stk500boot.c  **** #elif defined (__AVR_ATmega162__)
 248:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9404
 249:stk500boot.c  **** #elif defined (__AVR_ATmega128__)
 250:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9702
 251:stk500boot.c  **** #elif defined (__AVR_ATmega1280__)
 252:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9703
 253:stk500boot.c  **** #elif defined (__AVR_ATmega2560__)
 254:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9801
 255:stk500boot.c  **** #elif defined (__AVR_ATmega2561__)
 256:stk500boot.c  **** #define SIGNATURE_BYTES 0x1e9802
 257:stk500boot.c  **** #elif defined (__AVR_ATmega1284P__)
 258:stk500boot.c  **** #define SIGNATURE_BYTES 0x1e9705
 259:stk500boot.c  **** #elif defined (__AVR_ATmega640__)
 260:stk500boot.c  **** #define SIGNATURE_BYTES  0x1e9608
 261:stk500boot.c  **** #elif defined (__AVR_ATmega64__)
 262:stk500boot.c  **** #define SIGNATURE_BYTES  0x1E9602
 263:stk500boot.c  **** #elif defined (__AVR_ATmega169__)
 264:stk500boot.c  **** #define SIGNATURE_BYTES  0x1e9405
 265:stk500boot.c  **** #elif defined (__AVR_AT90USB1287__)
 266:stk500boot.c  **** #define SIGNATURE_BYTES  0x1e9782
 267:stk500boot.c  **** #else
 268:stk500boot.c  **** #error "no signature definition for MCU available"
 269:stk500boot.c  **** #endif
 270:stk500boot.c  **** 
 271:stk500boot.c  **** #if defined(_BOARD_ROBOTX_) || defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB1286__)
 272:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRR1L
 273:stk500boot.c  **** #define	UART_STATUS_REG				UCSR1A
 274:stk500boot.c  **** #define	UART_CONTROL_REG			UCSR1B
 275:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN1
 276:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN1
 277:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC1
 278:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC1
 279:stk500boot.c  **** #define	UART_DATA_REG				UDR1
 280:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X1
 281:stk500boot.c  **** 
 282:stk500boot.c  **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 283:stk500boot.c  **** 	|| defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 284:stk500boot.c  **** /* ATMega8 with one USART */
 285:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRRL
 286:stk500boot.c  **** #define	UART_STATUS_REG				UCSRA
 287:stk500boot.c  **** #define	UART_CONTROL_REG			UCSRB
 288:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN
 289:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN
 290:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC
 291:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC
 292:stk500boot.c  **** #define	UART_DATA_REG				UDR
 293:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X
 294:stk500boot.c  **** 
 295:stk500boot.c  **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega162__) \
 296:stk500boot.c  **** 	 || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
 297:stk500boot.c  **** /* ATMega with two USART, use UART0 */
 298:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRR0L
 299:stk500boot.c  **** #define	UART_STATUS_REG				UCSR0A
 300:stk500boot.c  **** #define	UART_CONTROL_REG			UCSR0B
 301:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN0
 302:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN0
 303:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC0
 304:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC0
 305:stk500boot.c  **** #define	UART_DATA_REG				UDR0
 306:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X0
 307:stk500boot.c  **** #elif defined(UBRR0L) && defined(UCSR0A) && defined(TXEN0)
 308:stk500boot.c  **** /* ATMega with two USART, use UART0 */
 309:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRR0L
 310:stk500boot.c  **** #define	UART_STATUS_REG				UCSR0A
 311:stk500boot.c  **** #define	UART_CONTROL_REG			UCSR0B
 312:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN0
 313:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN0
 314:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC0
 315:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC0
 316:stk500boot.c  **** #define	UART_DATA_REG				UDR0
 317:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X0
 318:stk500boot.c  **** #elif defined(UBRRL) && defined(UCSRA) && defined(UCSRB) && defined(TXEN) && defined(RXEN)
 319:stk500boot.c  **** //* catch all
 320:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRRL
 321:stk500boot.c  **** #define	UART_STATUS_REG				UCSRA
 322:stk500boot.c  **** #define	UART_CONTROL_REG			UCSRB
 323:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN
 324:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN
 325:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC
 326:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC
 327:stk500boot.c  **** #define	UART_DATA_REG				UDR
 328:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X
 329:stk500boot.c  **** #else
 330:stk500boot.c  **** #error "no UART definition for MCU available"
 331:stk500boot.c  **** #endif
 332:stk500boot.c  **** 
 333:stk500boot.c  **** #define SPI_MODE_MASK 0x0C  // CPOL = bit 3, CPHA = bit 2 on SPCR
 334:stk500boot.c  **** #define SPI_CLOCK_MASK 0x03  // SPR1 = bit 1, SPR0 = bit 0 on SPCR
 335:stk500boot.c  **** #define SPI_2XCLOCK_MASK 0x01  // SPI2X = bit 0 on SPSR
 336:stk500boot.c  **** 
 337:stk500boot.c  **** #define LSBFIRST 0
 338:stk500boot.c  **** #define MSBFIRST 1
 339:stk500boot.c  **** uint8_t transfer(uint8_t _data) {
 340:stk500boot.c  **** 	SPDR = _data;
 341:stk500boot.c  **** 	while (!(SPSR & _BV(SPIF)))
 342:stk500boot.c  **** 		;
 343:stk500boot.c  **** 	return SPDR;
 344:stk500boot.c  **** }
 345:stk500boot.c  **** void setDataMode(uint8_t mode) {
 346:stk500boot.c  **** 	SPCR = (SPCR & ~SPI_MODE_MASK) | mode;
 347:stk500boot.c  **** }
 348:stk500boot.c  **** 
 349:stk500boot.c  **** void setBitOrder(uint8_t bitOrder) {
 350:stk500boot.c  **** 	if (bitOrder == LSBFIRST) {
 351:stk500boot.c  **** 		SPCR |= _BV(DORD);
 352:stk500boot.c  **** 	} else {
 353:stk500boot.c  **** 		SPCR &= ~(_BV(DORD));
 354:stk500boot.c  **** 	}
 355:stk500boot.c  **** }
 356:stk500boot.c  **** 
 357:stk500boot.c  **** void setClockDivider(uint8_t rate) {
 358:stk500boot.c  **** 	SPCR = (SPCR & ~SPI_CLOCK_MASK) | (rate & SPI_CLOCK_MASK);
 359:stk500boot.c  **** 	SPSR = (SPSR & ~SPI_2XCLOCK_MASK) | ((rate >> 2) & SPI_2XCLOCK_MASK);
 360:stk500boot.c  **** }
 361:stk500boot.c  **** 
 362:stk500boot.c  **** /// return the STATUS register
 363:stk500boot.c  **** #define SPIFLASH_STATUSREAD       0x05
 364:stk500boot.c  **** uint8_t readStatus() {
 365:stk500boot.c  **** 	SS_LOW();
 366:stk500boot.c  **** 	SS_MASTER_HIGH();
 367:stk500boot.c  **** 	transfer(SPIFLASH_STATUSREAD);
 368:stk500boot.c  **** 	uint8_t status = transfer(0);
 369:stk500boot.c  **** 	SS_HIGH();
 370:stk500boot.c  **** 	SS_MASTER_LOW();
 371:stk500boot.c  **** 	return status;
 372:stk500boot.c  **** }
 373:stk500boot.c  **** uint8_t busy() {
 374:stk500boot.c  **** 	return readStatus() & 1;
 375:stk500boot.c  **** }
 376:stk500boot.c  **** 
 377:stk500boot.c  **** void command(uint8_t cmd) {
 378:stk500boot.c  **** 
 379:stk500boot.c  **** 	while (busy())
 380:stk500boot.c  **** 		; //wait for any write/erase to complete
 381:stk500boot.c  **** 	SS_LOW();
 382:stk500boot.c  **** 	transfer(cmd);
 383:stk500boot.c  **** }
 384:stk500boot.c  **** 
 385:stk500boot.c  **** #define SPIFLASH_ARRAYREADLOWFREQ 0x03
 386:stk500boot.c  **** uint8_t spiReadReg(uint32_t address) {
 387:stk500boot.c  **** 	SS_LOW();
 388:stk500boot.c  **** 	command(SPIFLASH_ARRAYREADLOWFREQ);
 389:stk500boot.c  **** 	transfer(address >> 16);
 390:stk500boot.c  **** 	transfer(address >> 8);
 391:stk500boot.c  **** 	transfer(address);
 392:stk500boot.c  **** 	uint8_t result = transfer(0);
 393:stk500boot.c  **** 	SS_HIGH();
 394:stk500boot.c  **** 	return result;
 395:stk500boot.c  **** }
 396:stk500boot.c  **** 
 397:stk500boot.c  **** /*
 398:stk500boot.c  ****  * Macro to calculate UBBR from XTAL and baudrate
 399:stk500boot.c  ****  */
 400:stk500boot.c  **** #if defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
 401:stk500boot.c  **** #define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
 402:stk500boot.c  **** #elif defined(__AVR_ATmega32__)
 403:stk500boot.c  **** #define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
 404:stk500boot.c  **** #elif UART_BAUDRATE_DOUBLE_SPEED
 405:stk500boot.c  **** #define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
 406:stk500boot.c  **** #else
 407:stk500boot.c  **** #define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.5)
 408:stk500boot.c  **** #endif
 409:stk500boot.c  **** 
 410:stk500boot.c  **** /*
 411:stk500boot.c  ****  * States used in the receive state machine
 412:stk500boot.c  ****  */
 413:stk500boot.c  **** #define	ST_START		0
 414:stk500boot.c  **** #define	ST_GET_SEQ_NUM	1
 415:stk500boot.c  **** #define ST_MSG_SIZE_1	2
 416:stk500boot.c  **** #define ST_MSG_SIZE_2	3
 417:stk500boot.c  **** #define ST_GET_TOKEN	4
 418:stk500boot.c  **** #define ST_GET_DATA		5
 419:stk500boot.c  **** #define	ST_GET_CHECK	6
 420:stk500boot.c  **** #define	ST_PROCESS		7
 421:stk500boot.c  **** 
 422:stk500boot.c  **** /*
 423:stk500boot.c  ****  * use 16bit address variable for ATmegas with <= 64K flash
 424:stk500boot.c  ****  */
 425:stk500boot.c  **** #if defined(RAMPZ)
 426:stk500boot.c  **** typedef uint32_t address_t;
 427:stk500boot.c  **** #else
 428:stk500boot.c  **** typedef uint16_t address_t;
 429:stk500boot.c  **** #endif
 430:stk500boot.c  **** 
 431:stk500boot.c  **** /*
 432:stk500boot.c  ****  * function prototypes
 433:stk500boot.c  ****  */
 434:stk500boot.c  **** static void sendchar(char c);
 435:stk500boot.c  **** 
 436:stk500boot.c  **** // SDCARD BOOTLOADER
 437:stk500boot.c  **** 
 438:stk500boot.c  **** unsigned char Buff[SPM_PAGESIZE]; /* Page data buffer */
 439:stk500boot.c  **** 
 440:stk500boot.c  **** // SDCARD BOOTLOADER
 441:stk500boot.c  **** 
 442:stk500boot.c  **** /*
 443:stk500boot.c  ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 444:stk500boot.c  ****  * to reduce the code size, we need to provide our own initialization
 445:stk500boot.c  ****  */
 446:stk500boot.c  **** void __jumpMain(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 447:stk500boot.c  **** #include <avr/sfr_defs.h>
 448:stk500boot.c  **** 
 449:stk500boot.c  **** //#define	SPH_REG	0x3E
 450:stk500boot.c  **** //#define	SPL_REG	0x3D
 451:stk500boot.c  **** 
 452:stk500boot.c  **** //*****************************************************************************
 453:stk500boot.c  **** void __jumpMain(void) {
 454:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 455:stk500boot.c  **** //*	the first line did not do the job on the ATmega128
 456:stk500boot.c  **** 
 457:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 458:stk500boot.c  **** 
 459:stk500boot.c  **** //*	set stack pointer to top of RAM
 460:stk500boot.c  **** 
 461:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 462:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 463:stk500boot.c  **** 
 464:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 465:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 466:stk500boot.c  **** 
 467:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );
 468:stk500boot.c  **** 	// GCC depends on register r1 set to 0
 469:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );
 470:stk500boot.c  **** 	// set SREG to 0
 471:stk500boot.c  **** 	asm volatile ( "jmp main");
 472:stk500boot.c  **** 	// jump to main()
 473:stk500boot.c  **** }
 474:stk500boot.c  **** 
 475:stk500boot.c  **** //*****************************************************************************
 476:stk500boot.c  **** void delay_ms(unsigned int timedelay) {
 477:stk500boot.c  **** 	unsigned int i;
 478:stk500boot.c  **** 	for (i = 0; i < timedelay; i++) {
 479:stk500boot.c  **** 		_delay_ms(0.5);
 480:stk500boot.c  **** 	}
 481:stk500boot.c  **** }
 482:stk500boot.c  **** 
 483:stk500boot.c  **** //*****************************************************************************
 484:stk500boot.c  **** /*
 485:stk500boot.c  ****  * send single byte to USART, wait until transmission is completed
 486:stk500boot.c  ****  */
 487:stk500boot.c  **** static void sendchar(char c) {
  15               		.loc 1 487 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 488:stk500boot.c  **** 	UART_DATA_REG = c; // prepare transmission
  22               		.loc 1 488 0
  23 0000 8093 C600 		sts 198,r24
  24               	.LVL1:
  25               	.L3:
 489:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)))
  26               		.loc 1 489 0 discriminator 1
  27 0004 8091 C000 		lds r24,192
  28 0008 86FF      		sbrs r24,6
  29 000a 00C0      		rjmp .L3
 490:stk500boot.c  **** 		; // wait until byte sent
 491:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE); // delete TXCflag
  30               		.loc 1 491 0
  31 000c 8091 C000 		lds r24,192
  32 0010 8064      		ori r24,lo8(64)
  33 0012 8093 C000 		sts 192,r24
  34               	.LVL2:
  35 0016 0895      		ret
  36               		.cfi_endproc
  37               	.LFE21:
  39               	.global	transfer
  41               	transfer:
  42               	.LFB11:
 339:stk500boot.c  **** uint8_t transfer(uint8_t _data) {
  43               		.loc 1 339 0
  44               		.cfi_startproc
  45               	.LVL3:
  46               	/* prologue: function */
  47               	/* frame size = 0 */
  48               	/* stack size = 0 */
  49               	.L__stack_usage = 0
 340:stk500boot.c  **** 	SPDR = _data;
  50               		.loc 1 340 0
  51 0018 8EBD      		out 0x2e,r24
  52               	.L7:
 341:stk500boot.c  **** 	while (!(SPSR & _BV(SPIF)))
  53               		.loc 1 341 0 discriminator 1
  54 001a 0DB4      		in __tmp_reg__,0x2d
  55 001c 07FE      		sbrs __tmp_reg__,7
  56 001e 00C0      		rjmp .L7
 343:stk500boot.c  **** 	return SPDR;
  57               		.loc 1 343 0
  58 0020 8EB5      		in r24,0x2e
  59               	.LVL4:
 344:stk500boot.c  **** }
  60               		.loc 1 344 0
  61 0022 0895      		ret
  62               		.cfi_endproc
  63               	.LFE11:
  65               	.global	setDataMode
  67               	setDataMode:
  68               	.LFB12:
 345:stk500boot.c  **** void setDataMode(uint8_t mode) {
  69               		.loc 1 345 0
  70               		.cfi_startproc
  71               	.LVL5:
  72               	/* prologue: function */
  73               	/* frame size = 0 */
  74               	/* stack size = 0 */
  75               	.L__stack_usage = 0
 346:stk500boot.c  **** 	SPCR = (SPCR & ~SPI_MODE_MASK) | mode;
  76               		.loc 1 346 0
  77 0024 9CB5      		in r25,0x2c
  78 0026 937F      		andi r25,lo8(-13)
  79 0028 982B      		or r25,r24
  80 002a 9CBD      		out 0x2c,r25
  81 002c 0895      		ret
  82               		.cfi_endproc
  83               	.LFE12:
  85               	.global	setBitOrder
  87               	setBitOrder:
  88               	.LFB13:
 349:stk500boot.c  **** void setBitOrder(uint8_t bitOrder) {
  89               		.loc 1 349 0
  90               		.cfi_startproc
  91               	.LVL6:
  92               	/* prologue: function */
  93               	/* frame size = 0 */
  94               	/* stack size = 0 */
  95               	.L__stack_usage = 0
 350:stk500boot.c  **** 	if (bitOrder == LSBFIRST) {
  96               		.loc 1 350 0
  97 002e 8111      		cpse r24,__zero_reg__
  98 0030 00C0      		rjmp .L10
 351:stk500boot.c  **** 		SPCR |= _BV(DORD);
  99               		.loc 1 351 0
 100 0032 8CB5      		in r24,0x2c
 101               	.LVL7:
 102 0034 8062      		ori r24,lo8(32)
 103 0036 00C0      		rjmp .L12
 104               	.LVL8:
 105               	.L10:
 353:stk500boot.c  **** 		SPCR &= ~(_BV(DORD));
 106               		.loc 1 353 0
 107 0038 8CB5      		in r24,0x2c
 108               	.LVL9:
 109 003a 8F7D      		andi r24,lo8(-33)
 110               	.L12:
 111 003c 8CBD      		out 0x2c,r24
 112 003e 0895      		ret
 113               		.cfi_endproc
 114               	.LFE13:
 116               	.global	setClockDivider
 118               	setClockDivider:
 119               	.LFB14:
 357:stk500boot.c  **** void setClockDivider(uint8_t rate) {
 120               		.loc 1 357 0
 121               		.cfi_startproc
 122               	.LVL10:
 123               	/* prologue: function */
 124               	/* frame size = 0 */
 125               	/* stack size = 0 */
 126               	.L__stack_usage = 0
 358:stk500boot.c  **** 	SPCR = (SPCR & ~SPI_CLOCK_MASK) | (rate & SPI_CLOCK_MASK);
 127               		.loc 1 358 0
 128 0040 2CB5      		in r18,0x2c
 129 0042 982F      		mov r25,r24
 130 0044 9370      		andi r25,lo8(3)
 131 0046 2C7F      		andi r18,lo8(-4)
 132 0048 922B      		or r25,r18
 133 004a 9CBD      		out 0x2c,r25
 359:stk500boot.c  **** 	SPSR = (SPSR & ~SPI_2XCLOCK_MASK) | ((rate >> 2) & SPI_2XCLOCK_MASK);
 134               		.loc 1 359 0
 135 004c 9DB5      		in r25,0x2d
 136 004e 82FB      		bst r24,2
 137 0050 8827      		clr r24
 138 0052 80F9      		bld r24,0
 139               	.LVL11:
 140 0054 9E7F      		andi r25,lo8(-2)
 141 0056 892B      		or r24,r25
 142 0058 8DBD      		out 0x2d,r24
 143 005a 0895      		ret
 144               		.cfi_endproc
 145               	.LFE14:
 147               	.global	readStatus
 149               	readStatus:
 150               	.LFB15:
 364:stk500boot.c  **** uint8_t readStatus() {
 151               		.loc 1 364 0
 152               		.cfi_startproc
 153               	/* prologue: function */
 154               	/* frame size = 0 */
 155               	/* stack size = 0 */
 156               	.L__stack_usage = 0
 365:stk500boot.c  **** 	SS_LOW();
 157               		.loc 1 365 0
 158 005c 7698      		cbi 0xe,6
 366:stk500boot.c  **** 	SS_MASTER_HIGH();
 159               		.loc 1 366 0
 160 005e 289A      		sbi 0x5,0
 367:stk500boot.c  **** 	transfer(SPIFLASH_STATUSREAD);
 161               		.loc 1 367 0
 162 0060 85E0      		ldi r24,lo8(5)
 163 0062 0E94 0000 		call transfer
 164               	.LVL12:
 368:stk500boot.c  **** 	uint8_t status = transfer(0);
 165               		.loc 1 368 0
 166 0066 80E0      		ldi r24,0
 167 0068 0E94 0000 		call transfer
 168               	.LVL13:
 369:stk500boot.c  **** 	SS_HIGH();
 169               		.loc 1 369 0
 170 006c 769A      		sbi 0xe,6
 370:stk500boot.c  **** 	SS_MASTER_LOW();
 171               		.loc 1 370 0
 172 006e 2898      		cbi 0x5,0
 372:stk500boot.c  **** }
 173               		.loc 1 372 0
 174 0070 0895      		ret
 175               		.cfi_endproc
 176               	.LFE15:
 178               	.global	busy
 180               	busy:
 181               	.LFB16:
 373:stk500boot.c  **** uint8_t busy() {
 182               		.loc 1 373 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 374:stk500boot.c  **** 	return readStatus() & 1;
 188               		.loc 1 374 0
 189 0072 0E94 0000 		call readStatus
 190               	.LVL14:
 375:stk500boot.c  **** }
 191               		.loc 1 375 0
 192 0076 8170      		andi r24,lo8(1)
 193 0078 0895      		ret
 194               		.cfi_endproc
 195               	.LFE16:
 197               	.global	command
 199               	command:
 200               	.LFB17:
 377:stk500boot.c  **** void command(uint8_t cmd) {
 201               		.loc 1 377 0
 202               		.cfi_startproc
 203               	.LVL15:
 204 007a CF93      		push r28
 205               	.LCFI0:
 206               		.cfi_def_cfa_offset 4
 207               		.cfi_offset 28, -3
 208               	/* prologue: function */
 209               	/* frame size = 0 */
 210               	/* stack size = 1 */
 211               	.L__stack_usage = 1
 212 007c C82F      		mov r28,r24
 213               	.LVL16:
 214               	.L18:
 379:stk500boot.c  **** 	while (busy())
 215               		.loc 1 379 0 discriminator 1
 216 007e 0E94 0000 		call busy
 217               	.LVL17:
 218 0082 8111      		cpse r24,__zero_reg__
 219 0084 00C0      		rjmp .L18
 381:stk500boot.c  **** 	SS_LOW();
 220               		.loc 1 381 0
 221 0086 7698      		cbi 0xe,6
 382:stk500boot.c  **** 	transfer(cmd);
 222               		.loc 1 382 0
 223 0088 8C2F      		mov r24,r28
 224               	/* epilogue start */
 383:stk500boot.c  **** }
 225               		.loc 1 383 0
 226 008a CF91      		pop r28
 227               	.LVL18:
 382:stk500boot.c  **** 	transfer(cmd);
 228               		.loc 1 382 0
 229 008c 0C94 0000 		jmp transfer
 230               	.LVL19:
 231               		.cfi_endproc
 232               	.LFE17:
 234               	.global	spiReadReg
 236               	spiReadReg:
 237               	.LFB18:
 386:stk500boot.c  **** uint8_t spiReadReg(uint32_t address) {
 238               		.loc 1 386 0
 239               		.cfi_startproc
 240               	.LVL20:
 241 0090 1F93      		push r17
 242               	.LCFI1:
 243               		.cfi_def_cfa_offset 4
 244               		.cfi_offset 17, -3
 245 0092 CF93      		push r28
 246               	.LCFI2:
 247               		.cfi_def_cfa_offset 5
 248               		.cfi_offset 28, -4
 249 0094 DF93      		push r29
 250               	.LCFI3:
 251               		.cfi_def_cfa_offset 6
 252               		.cfi_offset 29, -5
 253 0096 1F92      		push __zero_reg__
 254 0098 1F92      		push __zero_reg__
 255               	.LCFI4:
 256               		.cfi_def_cfa_offset 8
 257 009a CDB7      		in r28,__SP_L__
 258 009c DEB7      		in r29,__SP_H__
 259               	.LCFI5:
 260               		.cfi_def_cfa_register 28
 261               	/* prologue: function */
 262               	/* frame size = 2 */
 263               	/* stack size = 5 */
 264               	.L__stack_usage = 5
 265 009e 182F      		mov r17,r24
 387:stk500boot.c  **** 	SS_LOW();
 266               		.loc 1 387 0
 267 00a0 7698      		cbi 0xe,6
 388:stk500boot.c  **** 	command(SPIFLASH_ARRAYREADLOWFREQ);
 268               		.loc 1 388 0
 269 00a2 83E0      		ldi r24,lo8(3)
 270 00a4 6A83      		std Y+2,r22
 271 00a6 7983      		std Y+1,r23
 272 00a8 0E94 0000 		call command
 273               	.LVL21:
 389:stk500boot.c  **** 	transfer(address >> 16);
 274               		.loc 1 389 0
 275 00ac 812F      		mov r24,r17
 276 00ae 0E94 0000 		call transfer
 277               	.LVL22:
 390:stk500boot.c  **** 	transfer(address >> 8);
 278               		.loc 1 390 0
 279 00b2 7981      		ldd r23,Y+1
 280 00b4 872F      		mov r24,r23
 281 00b6 0E94 0000 		call transfer
 282               	.LVL23:
 391:stk500boot.c  **** 	transfer(address);
 283               		.loc 1 391 0
 284 00ba 6A81      		ldd r22,Y+2
 285 00bc 862F      		mov r24,r22
 286 00be 0E94 0000 		call transfer
 287               	.LVL24:
 392:stk500boot.c  **** 	uint8_t result = transfer(0);
 288               		.loc 1 392 0
 289 00c2 80E0      		ldi r24,0
 290 00c4 0E94 0000 		call transfer
 291               	.LVL25:
 393:stk500boot.c  **** 	SS_HIGH();
 292               		.loc 1 393 0
 293 00c8 769A      		sbi 0xe,6
 294               	/* epilogue start */
 395:stk500boot.c  **** }
 295               		.loc 1 395 0
 296 00ca 0F90      		pop __tmp_reg__
 297 00cc 0F90      		pop __tmp_reg__
 298 00ce DF91      		pop r29
 299 00d0 CF91      		pop r28
 300 00d2 1F91      		pop r17
 301 00d4 0895      		ret
 302               		.cfi_endproc
 303               	.LFE18:
 305               		.section	.init9,"ax",@progbits
 306               	.global	__jumpMain
 308               	__jumpMain:
 309               	.LFB19:
 453:stk500boot.c  **** void __jumpMain(void) {
 310               		.loc 1 453 0
 311               		.cfi_startproc
 312               	/* prologue: naked */
 313               	/* frame size = 0 */
 314               	/* stack size = 0 */
 315               	.L__stack_usage = 0
 457:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 316               		.loc 1 457 0
 317               	/* #APP */
 318               	 ;  457 "stk500boot.c" 1
 319               		.set __stack, 8703
 320               	 ;  0 "" 2
 461:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 321               		.loc 1 461 0
 322               	 ;  461 "stk500boot.c" 1
 323 0000 01E2      		ldi	16, 33
 324               	 ;  0 "" 2
 462:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 325               		.loc 1 462 0
 326               	 ;  462 "stk500boot.c" 1
 327 0002 0EBF      		out 62,16
 328               	 ;  0 "" 2
 464:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 329               		.loc 1 464 0
 330               	 ;  464 "stk500boot.c" 1
 331 0004 0FEF      		ldi	16, 255
 332               	 ;  0 "" 2
 465:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 333               		.loc 1 465 0
 334               	 ;  465 "stk500boot.c" 1
 335 0006 0DBF      		out 61,16
 336               	 ;  0 "" 2
 467:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );
 337               		.loc 1 467 0
 338               	 ;  467 "stk500boot.c" 1
 339 0008 1124      		clr __zero_reg__
 340               	 ;  0 "" 2
 469:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );
 341               		.loc 1 469 0
 342               	 ;  469 "stk500boot.c" 1
 343 000a 1FBE      		out 63, __zero_reg__
 344               	 ;  0 "" 2
 471:stk500boot.c  **** 	asm volatile ( "jmp main");
 345               		.loc 1 471 0
 346               	 ;  471 "stk500boot.c" 1
 347 000c 0C94 0000 		jmp main
 348               	 ;  0 "" 2
 349               	/* epilogue start */
 473:stk500boot.c  **** }
 350               		.loc 1 473 0
 351               	/* #NOAPP */
 352               		.cfi_endproc
 353               	.LFE19:
 355               		.text
 356               	.global	delay_ms
 358               	delay_ms:
 359               	.LFB20:
 476:stk500boot.c  **** void delay_ms(unsigned int timedelay) {
 360               		.loc 1 476 0
 361               		.cfi_startproc
 362               	.LVL26:
 363               	/* prologue: function */
 364               	/* frame size = 0 */
 365               	/* stack size = 0 */
 366               	.L__stack_usage = 0
 478:stk500boot.c  **** 	for (i = 0; i < timedelay; i++) {
 367               		.loc 1 478 0
 368 00d6 20E0      		ldi r18,0
 369 00d8 30E0      		ldi r19,0
 370               	.LVL27:
 371               	.L22:
 478:stk500boot.c  **** 	for (i = 0; i < timedelay; i++) {
 372               		.loc 1 478 0 is_stmt 0 discriminator 1
 373 00da 2817      		cp r18,r24
 374 00dc 3907      		cpc r19,r25
 375 00de 01F0      		breq .L24
 376               	.LVL28:
 377               	.LBB28:
 378               	.LBB29:
 379               		.file 2 "/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h"
   1:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 152:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 155:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 158:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 159:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 160:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 162:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 380               		.loc 2 163 0 is_stmt 1
 381 00e0 EFEC      		ldi r30,lo8(1999)
 382 00e2 F7E0      		ldi r31,hi8(1999)
 383 00e4 3197      		1: sbiw r30,1
 384 00e6 01F4      		brne 1b
 385 00e8 00C0      		rjmp .
 386 00ea 0000      		nop
 387               	.LBE29:
 388               	.LBE28:
 478:stk500boot.c  **** 	for (i = 0; i < timedelay; i++) {
 389               		.loc 1 478 0
 390 00ec 2F5F      		subi r18,-1
 391 00ee 3F4F      		sbci r19,-1
 392               	.LVL29:
 393 00f0 00C0      		rjmp .L22
 394               	.LVL30:
 395               	.L24:
 396               	/* epilogue start */
 481:stk500boot.c  **** }
 397               		.loc 1 481 0
 398 00f2 0895      		ret
 399               		.cfi_endproc
 400               	.LFE20:
 402               	.global	dec_hex
 404               	dec_hex:
 405               	.LFB24:
 492:stk500boot.c  **** }
 493:stk500boot.c  **** 
 494:stk500boot.c  **** //************************************************************************
 495:stk500boot.c  **** static int Serial_Available(void) {
 496:stk500boot.c  **** 	return (UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)); // wait for data
 497:stk500boot.c  **** }
 498:stk500boot.c  **** 
 499:stk500boot.c  **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
 500:stk500boot.c  **** //*****************************************************************************
 501:stk500boot.c  **** static unsigned char recchar_timeout(void) {
 502:stk500boot.c  **** 	uint32_t count = 0;
 503:stk500boot.c  **** 
 504:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE))) {
 505:stk500boot.c  **** 		// wait for data
 506:stk500boot.c  **** 		count++;
 507:stk500boot.c  **** 		if (count > MAX_TIME_COUNT) {
 508:stk500boot.c  **** 			unsigned int data;
 509:stk500boot.c  **** #if (FLASHEND > 0x10000)
 510:stk500boot.c  **** 			data = pgm_read_word_far(0); //*	get the first word of the user program
 511:stk500boot.c  **** #else
 512:stk500boot.c  **** 			data = pgm_read_word_near(0); //*	get the first word of the user program
 513:stk500boot.c  **** #endif
 514:stk500boot.c  **** 			if (data != 0xffff) //*	make sure its valid before jumping to it.
 515:stk500boot.c  **** 					{
 516:stk500boot.c  **** 				asm volatile(
 517:stk500boot.c  **** 						"clr	r30		\n\t"
 518:stk500boot.c  **** 						"clr	r31		\n\t"
 519:stk500boot.c  **** 						"ijmp	\n\t"
 520:stk500boot.c  **** 				);
 521:stk500boot.c  **** 			}
 522:stk500boot.c  **** 			count = 0;
 523:stk500boot.c  **** 		}
 524:stk500boot.c  **** 	}
 525:stk500boot.c  **** 	return UART_DATA_REG;
 526:stk500boot.c  **** }
 527:stk500boot.c  **** 
 528:stk500boot.c  **** 
 529:stk500boot.c  **** void dec_hex(long int num)   // Function Definition
 530:stk500boot.c  **** {
 406               		.loc 1 530 0
 407               		.cfi_startproc
 408               	.LVL31:
 409 00f4 CF92      		push r12
 410               	.LCFI6:
 411               		.cfi_def_cfa_offset 4
 412               		.cfi_offset 12, -3
 413 00f6 DF92      		push r13
 414               	.LCFI7:
 415               		.cfi_def_cfa_offset 5
 416               		.cfi_offset 13, -4
 417 00f8 EF92      		push r14
 418               	.LCFI8:
 419               		.cfi_def_cfa_offset 6
 420               		.cfi_offset 14, -5
 421 00fa FF92      		push r15
 422               	.LCFI9:
 423               		.cfi_def_cfa_offset 7
 424               		.cfi_offset 15, -6
 425 00fc 0F93      		push r16
 426               	.LCFI10:
 427               		.cfi_def_cfa_offset 8
 428               		.cfi_offset 16, -7
 429 00fe 1F93      		push r17
 430               	.LCFI11:
 431               		.cfi_def_cfa_offset 9
 432               		.cfi_offset 17, -8
 433 0100 CF93      		push r28
 434               	.LCFI12:
 435               		.cfi_def_cfa_offset 10
 436               		.cfi_offset 28, -9
 437 0102 DF93      		push r29
 438               	.LCFI13:
 439               		.cfi_def_cfa_offset 11
 440               		.cfi_offset 29, -10
 441 0104 CDB7      		in r28,__SP_L__
 442 0106 DEB7      		in r29,__SP_H__
 443               	.LCFI14:
 444               		.cfi_def_cfa_register 28
 445 0108 C85C      		subi r28,-56
 446 010a D109      		sbc r29,__zero_reg__
 447               	.LCFI15:
 448               		.cfi_def_cfa_offset 211
 449 010c 0FB6      		in __tmp_reg__,__SREG__
 450 010e F894      		cli
 451 0110 DEBF      		out __SP_H__,r29
 452 0112 0FBE      		out __SREG__,__tmp_reg__
 453 0114 CDBF      		out __SP_L__,r28
 454               	/* prologue: function */
 455               	/* frame size = 200 */
 456               	/* stack size = 208 */
 457               	.L__stack_usage = 208
 458 0116 6B01      		movw r12,r22
 459 0118 7C01      		movw r14,r24
 460               	.LVL32:
 531:stk500boot.c  **** long int rem[50],i=0,length=0;
 532:stk500boot.c  **** if(num == 0){
 461               		.loc 1 532 0
 462 011a 6115      		cp r22,__zero_reg__
 463 011c 7105      		cpc r23,__zero_reg__
 464 011e 8105      		cpc r24,__zero_reg__
 465 0120 9105      		cpc r25,__zero_reg__
 466 0122 01F4      		brne .L26
 533:stk500boot.c  **** 	sendchar('0');
 467               		.loc 1 533 0
 468 0124 80E3      		ldi r24,lo8(48)
 469 0126 0E94 0000 		call sendchar
 470               	.LVL33:
 534:stk500boot.c  **** 	sendchar('0');
 471               		.loc 1 534 0
 472 012a 80E3      		ldi r24,lo8(48)
 473 012c 0E94 0000 		call sendchar
 474               	.LVL34:
 475               	.L26:
 476 0130 FE01      		movw r30,r28
 477 0132 3196      		adiw r30,1
 530:stk500boot.c  **** {
 478               		.loc 1 530 0 discriminator 1
 479 0134 80E0      		ldi r24,0
 480 0136 90E0      		ldi r25,0
 481 0138 DC01      		movw r26,r24
 482 013a 8F01      		movw r16,r30
 483               	.LVL35:
 484               	.L27:
 535:stk500boot.c  **** }
 536:stk500boot.c  **** while(num>0)
 485               		.loc 1 536 0 discriminator 1
 486 013c 1C14      		cp __zero_reg__,r12
 487 013e 1D04      		cpc __zero_reg__,r13
 488 0140 1E04      		cpc __zero_reg__,r14
 489 0142 1F04      		cpc __zero_reg__,r15
 490 0144 04F4      		brge .L55
 537:stk500boot.c  ****    {
 538:stk500boot.c  ****       rem[i]=num%16;
 491               		.loc 1 538 0
 492 0146 B701      		movw r22,r14
 493 0148 A601      		movw r20,r12
 494 014a 4F70      		andi r20,15
 495 014c 5527      		clr r21
 496 014e 6627      		clr r22
 497 0150 7727      		clr r23
 498 0152 4193      		st Z+,r20
 499 0154 5193      		st Z+,r21
 500 0156 6193      		st Z+,r22
 501 0158 7193      		st Z+,r23
 539:stk500boot.c  ****       num=num/16;
 502               		.loc 1 539 0
 503 015a 24E0      		ldi r18,4
 504               		1:
 505 015c F594      		asr r15
 506 015e E794      		ror r14
 507 0160 D794      		ror r13
 508 0162 C794      		ror r12
 509 0164 2A95      		dec r18
 510 0166 01F4      		brne 1b
 511               	.LVL36:
 540:stk500boot.c  ****       i++;
 512               		.loc 1 540 0
 513 0168 0196      		adiw r24,1
 514 016a A11D      		adc r26,__zero_reg__
 515 016c B11D      		adc r27,__zero_reg__
 516               	.LVL37:
 517 016e 00C0      		rjmp .L27
 518               	.L55:
 541:stk500boot.c  ****       length++;
 542:stk500boot.c  ****    }
 543:stk500boot.c  **** 
 544:stk500boot.c  **** for(i=length-1;i>=0;i--)
 519               		.loc 1 544 0
 520 0170 6C01      		movw r12,r24
 521 0172 7D01      		movw r14,r26
 522               	.LVL38:
 523 0174 21E0      		ldi r18,1
 524 0176 C21A      		sub r12,r18
 525 0178 D108      		sbc r13,__zero_reg__
 526 017a E108      		sbc r14,__zero_reg__
 527 017c F108      		sbc r15,__zero_reg__
 528               	.LVL39:
 529               	.L29:
 530               		.loc 1 544 0 is_stmt 0 discriminator 1
 531 017e 2FEF      		ldi r18,-1
 532 0180 C216      		cp r12,r18
 533 0182 D206      		cpc r13,r18
 534 0184 E206      		cpc r14,r18
 535 0186 F206      		cpc r15,r18
 536 0188 01F4      		brne .+2
 537 018a 00C0      		rjmp .L56
 538 018c F601      		movw r30,r12
 539 018e EE0F      		lsl r30
 540 0190 FF1F      		rol r31
 541 0192 EE0F      		lsl r30
 542 0194 FF1F      		rol r31
 543 0196 E00F      		add r30,r16
 544 0198 F11F      		adc r31,r17
 545:stk500boot.c  ****   {
 546:stk500boot.c  ****     switch(rem[i])
 545               		.loc 1 546 0 is_stmt 1
 546 019a 8081      		ld r24,Z
 547 019c 9181      		ldd r25,Z+1
 548 019e A281      		ldd r26,Z+2
 549 01a0 B381      		ldd r27,Z+3
 550 01a2 8730      		cpi r24,7
 551 01a4 9105      		cpc r25,__zero_reg__
 552 01a6 A105      		cpc r26,__zero_reg__
 553 01a8 B105      		cpc r27,__zero_reg__
 554 01aa 01F4      		brne .+2
 555 01ac 00C0      		rjmp .L31
 556 01ae 04F4      		brge .L32
 557 01b0 8330      		cpi r24,3
 558 01b2 9105      		cpc r25,__zero_reg__
 559 01b4 A105      		cpc r26,__zero_reg__
 560 01b6 B105      		cpc r27,__zero_reg__
 561 01b8 01F0      		breq .L33
 562 01ba 04F4      		brge .L34
 563 01bc 8130      		cpi r24,1
 564 01be 9105      		cpc r25,__zero_reg__
 565 01c0 A105      		cpc r26,__zero_reg__
 566 01c2 B105      		cpc r27,__zero_reg__
 567 01c4 01F0      		breq .L35
 568 01c6 04F4      		brge .L36
 569 01c8 892B      		or r24,r25
 570 01ca 8A2B      		or r24,r26
 571 01cc 8B2B      		or r24,r27
 572 01ce 01F0      		breq .+2
 573 01d0 00C0      		rjmp .L30
 547:stk500boot.c  ****     {
 548:stk500boot.c  ****     case 0:
 549:stk500boot.c  ****         sendchar('0');
 574               		.loc 1 549 0
 575 01d2 80E3      		ldi r24,lo8(48)
 576 01d4 00C0      		rjmp .L54
 577               	.L34:
 546:stk500boot.c  ****     switch(rem[i])
 578               		.loc 1 546 0
 579 01d6 8530      		cpi r24,5
 580 01d8 9105      		cpc r25,__zero_reg__
 581 01da A105      		cpc r26,__zero_reg__
 582 01dc B105      		cpc r27,__zero_reg__
 583 01de 01F0      		breq .L38
 584 01e0 04F4      		brge .L57
 550:stk500boot.c  ****         break;
 551:stk500boot.c  ****     case 1:
 552:stk500boot.c  ****         sendchar('1');
 553:stk500boot.c  ****         break;
 554:stk500boot.c  ****     case 2:
 555:stk500boot.c  ****         sendchar('2');
 556:stk500boot.c  ****         break;
 557:stk500boot.c  ****     case 3:
 558:stk500boot.c  ****         sendchar('3');
 559:stk500boot.c  ****         break;
 560:stk500boot.c  ****     case 4:
 561:stk500boot.c  ****         sendchar('4');
 585               		.loc 1 561 0
 586 01e2 84E3      		ldi r24,lo8(52)
 587 01e4 00C0      		rjmp .L54
 588               	.L32:
 546:stk500boot.c  ****     switch(rem[i])
 589               		.loc 1 546 0
 590 01e6 8B30      		cpi r24,11
 591 01e8 9105      		cpc r25,__zero_reg__
 592 01ea A105      		cpc r26,__zero_reg__
 593 01ec B105      		cpc r27,__zero_reg__
 594 01ee 01F0      		breq .L41
 595 01f0 04F4      		brge .L42
 596 01f2 8930      		cpi r24,9
 597 01f4 9105      		cpc r25,__zero_reg__
 598 01f6 A105      		cpc r26,__zero_reg__
 599 01f8 B105      		cpc r27,__zero_reg__
 600 01fa 01F0      		breq .L43
 601 01fc 04F4      		brge .L58
 562:stk500boot.c  ****         break;
 563:stk500boot.c  ****     case 5:
 564:stk500boot.c  ****         sendchar('5');
 565:stk500boot.c  ****         break;
 566:stk500boot.c  ****     case 6:
 567:stk500boot.c  ****         sendchar('6');
 568:stk500boot.c  ****         break;
 569:stk500boot.c  ****     case 7:
 570:stk500boot.c  ****         sendchar('7');
 571:stk500boot.c  ****         break;
 572:stk500boot.c  ****     case 8:
 573:stk500boot.c  ****         sendchar('8');
 602               		.loc 1 573 0
 603 01fe 88E3      		ldi r24,lo8(56)
 604 0200 00C0      		rjmp .L54
 605               	.L42:
 546:stk500boot.c  ****     switch(rem[i])
 606               		.loc 1 546 0
 607 0202 8D30      		cpi r24,13
 608 0204 9105      		cpc r25,__zero_reg__
 609 0206 A105      		cpc r26,__zero_reg__
 610 0208 B105      		cpc r27,__zero_reg__
 611 020a 01F0      		breq .L46
 612 020c 04F0      		brlt .L47
 613 020e 8E30      		cpi r24,14
 614 0210 9105      		cpc r25,__zero_reg__
 615 0212 A105      		cpc r26,__zero_reg__
 616 0214 B105      		cpc r27,__zero_reg__
 617 0216 01F0      		breq .L48
 618 0218 0F97      		sbiw r24,15
 619 021a A105      		cpc r26,__zero_reg__
 620 021c B105      		cpc r27,__zero_reg__
 621 021e 01F4      		brne .L30
 574:stk500boot.c  ****         break;
 575:stk500boot.c  ****     case 9:
 576:stk500boot.c  ****         sendchar('9');
 577:stk500boot.c  ****         break;
 578:stk500boot.c  ****       case 10:
 579:stk500boot.c  ****           sendchar('A');
 580:stk500boot.c  ****           break;
 581:stk500boot.c  ****       case 11:
 582:stk500boot.c  ****     	  sendchar('B');
 583:stk500boot.c  ****           break;
 584:stk500boot.c  ****       case 12:
 585:stk500boot.c  ****     	  sendchar('C');
 586:stk500boot.c  ****           break;
 587:stk500boot.c  ****       case 13:
 588:stk500boot.c  ****     	  sendchar('D');
 589:stk500boot.c  ****           break;
 590:stk500boot.c  ****       case 14:
 591:stk500boot.c  ****     	  sendchar('E');
 592:stk500boot.c  ****           break;
 593:stk500boot.c  ****       case 15:
 594:stk500boot.c  ****     	  sendchar('F');
 622               		.loc 1 594 0
 623 0220 86E4      		ldi r24,lo8(70)
 624 0222 00C0      		rjmp .L54
 625               	.L35:
 552:stk500boot.c  ****         sendchar('1');
 626               		.loc 1 552 0
 627 0224 81E3      		ldi r24,lo8(49)
 628 0226 00C0      		rjmp .L54
 629               	.L36:
 555:stk500boot.c  ****         sendchar('2');
 630               		.loc 1 555 0
 631 0228 82E3      		ldi r24,lo8(50)
 632 022a 00C0      		rjmp .L54
 633               	.L33:
 558:stk500boot.c  ****         sendchar('3');
 634               		.loc 1 558 0
 635 022c 83E3      		ldi r24,lo8(51)
 636 022e 00C0      		rjmp .L54
 637               	.L38:
 564:stk500boot.c  ****         sendchar('5');
 638               		.loc 1 564 0
 639 0230 85E3      		ldi r24,lo8(53)
 640 0232 00C0      		rjmp .L54
 641               	.L57:
 567:stk500boot.c  ****         sendchar('6');
 642               		.loc 1 567 0
 643 0234 86E3      		ldi r24,lo8(54)
 644 0236 00C0      		rjmp .L54
 645               	.L31:
 570:stk500boot.c  ****         sendchar('7');
 646               		.loc 1 570 0
 647 0238 87E3      		ldi r24,lo8(55)
 648 023a 00C0      		rjmp .L54
 649               	.L43:
 576:stk500boot.c  ****         sendchar('9');
 650               		.loc 1 576 0
 651 023c 89E3      		ldi r24,lo8(57)
 652 023e 00C0      		rjmp .L54
 653               	.L58:
 579:stk500boot.c  ****           sendchar('A');
 654               		.loc 1 579 0
 655 0240 81E4      		ldi r24,lo8(65)
 656 0242 00C0      		rjmp .L54
 657               	.L41:
 582:stk500boot.c  ****     	  sendchar('B');
 658               		.loc 1 582 0
 659 0244 82E4      		ldi r24,lo8(66)
 660 0246 00C0      		rjmp .L54
 661               	.L47:
 585:stk500boot.c  ****     	  sendchar('C');
 662               		.loc 1 585 0
 663 0248 83E4      		ldi r24,lo8(67)
 664 024a 00C0      		rjmp .L54
 665               	.L46:
 588:stk500boot.c  ****     	  sendchar('D');
 666               		.loc 1 588 0
 667 024c 84E4      		ldi r24,lo8(68)
 668 024e 00C0      		rjmp .L54
 669               	.L48:
 591:stk500boot.c  ****     	  sendchar('E');
 670               		.loc 1 591 0
 671 0250 85E4      		ldi r24,lo8(69)
 672 0252 00C0      		rjmp .L54
 673               	.L30:
 595:stk500boot.c  ****           break;
 596:stk500boot.c  ****       default :
 597:stk500boot.c  ****          sendchar('X');
 674               		.loc 1 597 0
 675 0254 88E5      		ldi r24,lo8(88)
 676               	.L54:
 677 0256 0E94 0000 		call sendchar
 678               	.LVL40:
 544:stk500boot.c  **** for(i=length-1;i>=0;i--)
 679               		.loc 1 544 0
 680 025a 81E0      		ldi r24,1
 681 025c C81A      		sub r12,r24
 682 025e D108      		sbc r13,__zero_reg__
 683 0260 E108      		sbc r14,__zero_reg__
 684 0262 F108      		sbc r15,__zero_reg__
 685               	.LVL41:
 686 0264 00C0      		rjmp .L29
 687               	.L56:
 688               	/* epilogue start */
 598:stk500boot.c  ****          break;
 599:stk500boot.c  ****     }
 600:stk500boot.c  ****   }
 601:stk500boot.c  **** }
 689               		.loc 1 601 0
 690 0266 C853      		subi r28,56
 691 0268 DF4F      		sbci r29,-1
 692 026a 0FB6      		in __tmp_reg__,__SREG__
 693 026c F894      		cli
 694 026e DEBF      		out __SP_H__,r29
 695 0270 0FBE      		out __SREG__,__tmp_reg__
 696 0272 CDBF      		out __SP_L__,r28
 697 0274 DF91      		pop r29
 698 0276 CF91      		pop r28
 699 0278 1F91      		pop r17
 700 027a 0F91      		pop r16
 701 027c FF90      		pop r15
 702 027e EF90      		pop r14
 703 0280 DF90      		pop r13
 704 0282 CF90      		pop r12
 705               	.LVL42:
 706 0284 0895      		ret
 707               		.cfi_endproc
 708               	.LFE24:
 710               		.section	.text.startup,"ax",@progbits
 711               	.global	main
 713               	main:
 714               	.LFB25:
 602:stk500boot.c  **** 
 603:stk500boot.c  **** 
 604:stk500boot.c  **** //*	for watch dog timer startup
 605:stk500boot.c  **** void (*app_start)(void) = 0;
 606:stk500boot.c  **** uint8_t check = 1;
 607:stk500boot.c  **** 
 608:stk500boot.c  **** //*****************************************************************************
 609:stk500boot.c  **** int main(void) {
 715               		.loc 1 609 0
 716               		.cfi_startproc
 717 0000 CF93      		push r28
 718               	.LCFI16:
 719               		.cfi_def_cfa_offset 4
 720               		.cfi_offset 28, -3
 721 0002 DF93      		push r29
 722               	.LCFI17:
 723               		.cfi_def_cfa_offset 5
 724               		.cfi_offset 29, -4
 725 0004 CDB7      		in r28,__SP_L__
 726 0006 DEB7      		in r29,__SP_H__
 727               	.LCFI18:
 728               		.cfi_def_cfa_register 28
 729 0008 C952      		subi r28,41
 730 000a D140      		sbci r29,1
 731               	.LCFI19:
 732               		.cfi_def_cfa_offset 302
 733 000c 0FB6      		in __tmp_reg__,__SREG__
 734 000e F894      		cli
 735 0010 DEBF      		out __SP_H__,r29
 736 0012 0FBE      		out __SREG__,__tmp_reg__
 737 0014 CDBF      		out __SP_L__,r28
 738               	/* prologue: function */
 739               	/* frame size = 297 */
 740               	/* stack size = 299 */
 741               	.L__stack_usage = 299
 610:stk500boot.c  **** 
 611:stk500boot.c  **** 	setDataMode(0x00);
 742               		.loc 1 611 0
 743 0016 80E0      		ldi r24,0
 744 0018 0E94 0000 		call setDataMode
 745               	.LVL43:
 612:stk500boot.c  **** 	setBitOrder(1);
 746               		.loc 1 612 0
 747 001c 81E0      		ldi r24,lo8(1)
 748 001e 0E94 0000 		call setBitOrder
 749               	.LVL44:
 613:stk500boot.c  **** 	setClockDivider(0x04);
 750               		.loc 1 613 0
 751 0022 84E0      		ldi r24,lo8(4)
 752 0024 0E94 0000 		call setClockDivider
 753               	.LVL45:
 614:stk500boot.c  **** 	SPI_PORTA = _BV(LED1) | _BV(LED2) | _BV(LED3);
 754               		.loc 1 614 0
 755 0028 87E0      		ldi r24,lo8(7)
 756 002a 82B9      		out 0x2,r24
 615:stk500boot.c  **** 	SPI_DDRA = _BV(LED1) | _BV(LED2) | _BV(LED3);
 757               		.loc 1 615 0
 758 002c 81B9      		out 0x1,r24
 616:stk500boot.c  **** 	SPI_PORTB = _BV(SCK) | _BV(MISO) | _BV(MOSI)  ;
 759               		.loc 1 616 0
 760 002e 8EE0      		ldi r24,lo8(14)
 761 0030 85B9      		out 0x5,r24
 617:stk500boot.c  **** 	SPI_DDRB = _BV(SCK) | _BV(MOSI);
 762               		.loc 1 617 0
 763 0032 86E0      		ldi r24,lo8(6)
 764 0034 84B9      		out 0x4,r24
 618:stk500boot.c  **** 	SPI_PORTE = _BV(SS);
 765               		.loc 1 618 0
 766 0036 80E4      		ldi r24,lo8(64)
 767 0038 8EB9      		out 0xe,r24
 619:stk500boot.c  **** 	SPI_DDRE = _BV(SS);
 768               		.loc 1 619 0
 769 003a 8DB9      		out 0xd,r24
 620:stk500boot.c  **** 
 621:stk500boot.c  **** 	LED1_LOW();
 770               		.loc 1 621 0
 771 003c 1098      		cbi 0x2,0
 622:stk500boot.c  **** 	LED2_LOW();
 772               		.loc 1 622 0
 773 003e 1198      		cbi 0x2,1
 623:stk500boot.c  **** 	LED3_LOW();
 774               		.loc 1 623 0
 775 0040 1298      		cbi 0x2,2
 624:stk500boot.c  **** 	
 625:stk500boot.c  **** 	SS_HIGH();
 776               		.loc 1 625 0
 777 0042 769A      		sbi 0xe,6
 626:stk500boot.c  **** 	SS_MASTER_HIGH();
 778               		.loc 1 626 0
 779 0044 289A      		sbi 0x5,0
 627:stk500boot.c  **** 
 628:stk500boot.c  **** 	SPCR |= _BV(MSTR);
 780               		.loc 1 628 0
 781 0046 8CB5      		in r24,0x2c
 782 0048 8061      		ori r24,lo8(16)
 783 004a 8CBD      		out 0x2c,r24
 629:stk500boot.c  **** 	SPCR |= _BV(SPE);
 784               		.loc 1 629 0
 785 004c 8CB5      		in r24,0x2c
 786 004e 8064      		ori r24,lo8(64)
 787 0050 8CBD      		out 0x2c,r24
 788               	.LVL46:
 630:stk500boot.c  **** 
 631:stk500boot.c  **** 	address_t address = 0;
 632:stk500boot.c  **** 	address_t eraseAddress = 0;
 633:stk500boot.c  **** 	unsigned char msgParseState;
 634:stk500boot.c  **** 	unsigned int ii = 0;
 635:stk500boot.c  **** 	unsigned char checksum = 0;
 636:stk500boot.c  **** 	unsigned char seqNum = 0;
 637:stk500boot.c  **** 	unsigned int msgLength = 0;
 638:stk500boot.c  **** 	unsigned char msgBuffer[285];
 639:stk500boot.c  **** 	unsigned char c, *p;
 640:stk500boot.c  **** 	unsigned char isLeave = 0;
 641:stk500boot.c  **** 
 642:stk500boot.c  **** 	unsigned long boot_timeout;
 643:stk500boot.c  **** 	unsigned long boot_timer;
 644:stk500boot.c  **** 	unsigned int boot_state;
 645:stk500boot.c  **** #ifdef ENABLE_MONITOR
 646:stk500boot.c  **** 	unsigned int exPointCntr = 0;
 647:stk500boot.c  **** 	unsigned int rcvdCharCntr = 0;
 648:stk500boot.c  **** #endif
 649:stk500boot.c  **** 
 650:stk500boot.c  **** 	//*	some chips dont set the stack properly
 651:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 789               		.loc 1 651 0
 790               	/* #APP */
 791               	 ;  651 "stk500boot.c" 1
 792               		.set __stack, 8703
 793               	 ;  0 "" 2
 652:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 794               		.loc 1 652 0
 795               	 ;  652 "stk500boot.c" 1
 796 0052 01E2      		ldi	16, 33
 797               	 ;  0 "" 2
 653:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 798               		.loc 1 653 0
 799               	 ;  653 "stk500boot.c" 1
 800 0054 0EBF      		out 62,16
 801               	 ;  0 "" 2
 654:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 802               		.loc 1 654 0
 803               	 ;  654 "stk500boot.c" 1
 804 0056 0FEF      		ldi	16, 255
 805               	 ;  0 "" 2
 655:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 806               		.loc 1 655 0
 807               	 ;  655 "stk500boot.c" 1
 808 0058 0DBF      		out 61,16
 809               	 ;  0 "" 2
 656:stk500boot.c  **** 
 657:stk500boot.c  **** #ifdef _FIX_ISSUE_181_
 658:stk500boot.c  **** 	//************************************************************************
 659:stk500boot.c  **** 	//*	Dec 29,	2011	<MLS> Issue #181, added watch dog timmer support
 660:stk500boot.c  **** 	//*	handle the watch dog timer
 661:stk500boot.c  **** 	uint8_t mcuStatusReg;
 662:stk500boot.c  **** 	mcuStatusReg = MCUSR;
 810               		.loc 1 662 0
 811               	/* #NOAPP */
 812 005a 94B7      		in r25,0x34
 813               	.LVL47:
 663:stk500boot.c  **** 
 664:stk500boot.c  **** 	__asm__ __volatile__ ("cli");
 814               		.loc 1 664 0
 815               	/* #APP */
 816               	 ;  664 "stk500boot.c" 1
 817 005c F894      		cli
 818               	 ;  0 "" 2
 665:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 819               		.loc 1 665 0
 820               	 ;  665 "stk500boot.c" 1
 821 005e A895      		wdr
 822               	 ;  0 "" 2
 666:stk500boot.c  **** 	MCUSR = 0;
 823               		.loc 1 666 0
 824               	/* #NOAPP */
 825 0060 14BE      		out 0x34,__zero_reg__
 667:stk500boot.c  **** 	WDTCSR |= _BV(WDCE) | _BV(WDE);
 826               		.loc 1 667 0
 827 0062 8091 6000 		lds r24,96
 828 0066 8861      		ori r24,lo8(24)
 829 0068 8093 6000 		sts 96,r24
 668:stk500boot.c  **** 	WDTCSR = 0;
 830               		.loc 1 668 0
 831 006c 1092 6000 		sts 96,__zero_reg__
 669:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 832               		.loc 1 669 0
 833               	/* #APP */
 834               	 ;  669 "stk500boot.c" 1
 835 0070 7894      		sei
 836               	 ;  0 "" 2
 670:stk500boot.c  **** 
 671:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 672:stk500boot.c  **** 	if (mcuStatusReg & _BV(WDRF)) {
 837               		.loc 1 672 0
 838               	/* #NOAPP */
 839 0072 93FF      		sbrs r25,3
 840 0074 00C0      		rjmp .L60
 673:stk500boot.c  **** 		app_start();
 841               		.loc 1 673 0
 842 0076 E091 0000 		lds r30,app_start
 843 007a F091 0000 		lds r31,app_start+1
 844 007e 1995      		eicall
 845               	.LVL48:
 846               	.L60:
 674:stk500boot.c  **** 	}
 675:stk500boot.c  **** 	//************************************************************************
 676:stk500boot.c  **** #endif
 677:stk500boot.c  **** 
 678:stk500boot.c  **** 	boot_timer = 0;
 679:stk500boot.c  **** 	boot_state = 0;
 680:stk500boot.c  **** 
 681:stk500boot.c  **** #ifdef BLINK_LED_WHILE_WAITING
 682:stk500boot.c  **** //	boot_timeout	=	 90000;		//*	should be about 4 seconds
 683:stk500boot.c  **** //	boot_timeout	=	170000;
 684:stk500boot.c  **** 	boot_timeout = 100000; //*	should be about 1 second
 685:stk500boot.c  **** #else
 686:stk500boot.c  **** 			boot_timeout = 3500000; // 7 seconds , approx 2us per step when optimize "s"
 687:stk500boot.c  **** #endif
 688:stk500boot.c  **** 	/*
 689:stk500boot.c  **** 	 * Branch to bootloader or application code ?
 690:stk500boot.c  **** 	 */
 691:stk500boot.c  **** 
 692:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
 693:stk500boot.c  **** 	/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 694:stk500boot.c  **** 			//PROGLED_DDR |= (1 << PROGLED_PIN);
 695:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 696:stk500boot.c  **** //	PROGLED_PORT |= (1 << PROGLED_PIN); // active high LED ON
 697:stk500boot.c  **** 
 698:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
 699:stk500boot.c  **** //	for (ii=0; ii<3; ii++)
 700:stk500boot.c  **** //	{
 701:stk500boot.c  **** //		PROGLED_PORT &= ~(1<<PROGLED_PIN); // turn LED off
 702:stk500boot.c  **** //		delay_ms(100);
 703:stk500boot.c  **** //		PROGLED_PORT |= (1<<PROGLED_PIN);// turn LED on
 704:stk500boot.c  **** //		delay_ms(100);
 705:stk500boot.c  **** //	}
 706:stk500boot.c  **** #endif
 707:stk500boot.c  **** 
 708:stk500boot.c  **** #endif
 709:stk500boot.c  **** 
 710:stk500boot.c  **** 	/*
 711:stk500boot.c  **** 	 * Init UART
 712:stk500boot.c  **** 	 * set baudrate and enable USART receiver and transmiter without interrupts
 713:stk500boot.c  **** 	 */
 714:stk500boot.c  **** #if UART_BAUDRATE_DOUBLE_SPEED
 715:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_DOUBLE_SPEED);
 847               		.loc 1 715 0
 848 0080 8091 C000 		lds r24,192
 849 0084 8260      		ori r24,lo8(2)
 850 0086 8093 C000 		sts 192,r24
 716:stk500boot.c  **** #endif
 717:stk500boot.c  **** 	UART_BAUD_RATE_LOW = UART_BAUD_SELECT(BAUDRATE,F_CPU);
 851               		.loc 1 717 0
 852 008a 80E1      		ldi r24,lo8(16)
 853 008c 8093 C400 		sts 196,r24
 718:stk500boot.c  **** 	UART_CONTROL_REG = (1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 854               		.loc 1 718 0
 855 0090 88E1      		ldi r24,lo8(24)
 856 0092 8093 C100 		sts 193,r24
 719:stk500boot.c  **** 
 720:stk500boot.c  **** 	asm volatile ("nop");
 857               		.loc 1 720 0
 858               	/* #APP */
 859               	 ;  720 "stk500boot.c" 1
 860 0096 0000      		nop
 861               	 ;  0 "" 2
 678:stk500boot.c  **** 	boot_timer = 0;
 862               		.loc 1 678 0
 863               	/* #NOAPP */
 864 0098 80E0      		ldi r24,0
 865 009a 90E0      		ldi r25,0
 866 009c DC01      		movw r26,r24
 867               	.LVL49:
 868               	.L61:
 609:stk500boot.c  **** int main(void) {
 869               		.loc 1 609 0 discriminator 1
 870 009e 40E0      		ldi r20,0
 871 00a0 50E0      		ldi r21,0
 872               	.LVL50:
 873               	.L68:
 874               	.LBB58:
 875               	.LBB59:
 496:stk500boot.c  **** 	return (UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)); // wait for data
 876               		.loc 1 496 0 discriminator 1
 877 00a2 2091 C000 		lds r18,192
 878               	.LBE59:
 879               	.LBE58:
 721:stk500boot.c  **** 	// wait until port has changed
 722:stk500boot.c  **** 
 723:stk500boot.c  **** //	sendchar('b');
 724:stk500boot.c  **** //    sendchar('o');
 725:stk500boot.c  **** //    sendchar('o');
 726:stk500boot.c  **** //    sendchar('t');
 727:stk500boot.c  **** //    sendchar('i');
 728:stk500boot.c  **** //    sendchar('n');
 729:stk500boot.c  **** //    sendchar('g');
 730:stk500boot.c  **** //    sendchar('.');
 731:stk500boot.c  **** //    sendchar('.');
 732:stk500boot.c  **** //    sendchar('.');
 733:stk500boot.c  **** //    sendchar(0x0d);
 734:stk500boot.c  **** //    sendchar(0x0a);
 735:stk500boot.c  **** //    delay_ms(100);
 736:stk500boot.c  **** 
 737:stk500boot.c  **** 	while (boot_state == 0) {
 738:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0)) // wait for data
 880               		.loc 1 738 0 discriminator 1
 881 00a6 27FF      		sbrs r18,7
 882 00a8 00C0      		rjmp .L63
 883               	.L67:
 739:stk500boot.c  **** 		{
 740:stk500boot.c  **** 			_delay_ms(0.001);
 741:stk500boot.c  **** 			boot_timer++;
 742:stk500boot.c  **** 			if (boot_timer > boot_timeout) {
 743:stk500boot.c  **** 				boot_state = 1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 744:stk500boot.c  **** 			}
 745:stk500boot.c  **** #ifdef BLINK_LED_WHILE_WAITING
 746:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0) {
 747:stk500boot.c  **** 				//*	toggle the LED
 748:stk500boot.c  **** 				//PROGLED_PORT ^= (1 << PROGLED_PIN); // turn LED ON
 749:stk500boot.c  **** 			}
 750:stk500boot.c  **** #endif
 751:stk500boot.c  **** 		}
 752:stk500boot.c  **** 		/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 753:stk500boot.c  **** 		//	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 754:stk500boot.c  **** 		// SDCARD BOOTLOADER
 755:stk500boot.c  **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
 884               		.loc 1 755 0
 885 00aa 4F5F      		subi r20,-1
 886 00ac 5F4F      		sbci r21,-1
 887               	.LVL51:
 737:stk500boot.c  **** 	while (boot_state == 0) {
 888               		.loc 1 737 0
 889 00ae 4115      		cp r20,__zero_reg__
 890 00b0 5105      		cpc r21,__zero_reg__
 891 00b2 01F0      		breq .L61
 892 00b4 00C0      		rjmp .L198
 893               	.L63:
 738:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0)) // wait for data
 894               		.loc 1 738 0 discriminator 2
 895 00b6 4115      		cp r20,__zero_reg__
 896 00b8 5105      		cpc r21,__zero_reg__
 897 00ba 01F4      		brne .L67
 898               	.LVL52:
 899               	.LBB60:
 900               	.LBB61:
 901               		.loc 2 163 0
 902 00bc 25E0      		ldi r18,lo8(5)
 903 00be 2A95      		1: dec r18
 904 00c0 01F4      		brne 1b
 905 00c2 0000      		nop
 906               	.LBE61:
 907               	.LBE60:
 741:stk500boot.c  **** 			boot_timer++;
 908               		.loc 1 741 0
 909 00c4 0196      		adiw r24,1
 910 00c6 A11D      		adc r26,__zero_reg__
 911 00c8 B11D      		adc r27,__zero_reg__
 912               	.LVL53:
 742:stk500boot.c  **** 			if (boot_timer > boot_timeout) {
 913               		.loc 1 742 0
 914 00ca 31E0      		ldi r19,lo8(1)
 915 00cc 20E0      		ldi r18,0
 916 00ce 813A      		cpi r24,-95
 917 00d0 46E8      		ldi r20,-122
 918 00d2 9407      		cpc r25,r20
 919 00d4 41E0      		ldi r20,1
 920 00d6 A407      		cpc r26,r20
 921 00d8 B105      		cpc r27,__zero_reg__
 922               	.LVL54:
 923 00da 00F4      		brsh .L62
 924 00dc 30E0      		ldi r19,0
 925               	.L62:
 743:stk500boot.c  **** 				boot_state = 1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 926               		.loc 1 743 0
 927 00de 432F      		mov r20,r19
 928 00e0 522F      		mov r21,r18
 929 00e2 00C0      		rjmp .L68
 930               	.LVL55:
 931               	.L198:
 756:stk500boot.c  **** 	}
 757:stk500boot.c  **** 
 758:stk500boot.c  **** 	if (boot_state == 1) {
 932               		.loc 1 758 0
 933 00e4 4130      		cpi r20,1
 934 00e6 5105      		cpc r21,__zero_reg__
 935 00e8 01F0      		breq .+2
 936 00ea 00C0      		rjmp .L69
 937 00ec CE5D      		subi r28,lo8(-290)
 938 00ee DE4F      		sbci r29,hi8(-290)
 939 00f0 1982      		std Y+1,__zero_reg__
 940 00f2 1882      		st Y,__zero_reg__
 941 00f4 C252      		subi r28,lo8(290)
 942 00f6 D140      		sbci r29,hi8(290)
 943 00f8 C85D      		subi r28,lo8(-296)
 944 00fa DE4F      		sbci r29,hi8(-296)
 945 00fc 1982      		std Y+1,__zero_reg__
 946 00fe 1882      		st Y,__zero_reg__
 947 0100 C852      		subi r28,lo8(296)
 948 0102 D140      		sbci r29,hi8(296)
 949 0104 C05E      		subi r28,lo8(-288)
 950 0106 DE4F      		sbci r29,hi8(-288)
 951 0108 1882      		st Y,__zero_reg__
 952 010a C052      		subi r28,lo8(288)
 953 010c D140      		sbci r29,hi8(288)
 954 010e 312C      		mov r3,__zero_reg__
 955 0110 C25E      		subi r28,lo8(-286)
 956 0112 DE4F      		sbci r29,hi8(-286)
 957 0114 1982      		std Y+1,__zero_reg__
 958 0116 1882      		st Y,__zero_reg__
 959 0118 CE51      		subi r28,lo8(286)
 960 011a D140      		sbci r29,hi8(286)
 961 011c C12C      		mov r12,__zero_reg__
 962 011e D12C      		mov r13,__zero_reg__
 963 0120 7601      		movw r14,r12
 964 0122 412C      		mov r4,__zero_reg__
 965 0124 512C      		mov r5,__zero_reg__
 966 0126 3201      		movw r6,r4
 967               	.LVL56:
 968               	.L70:
 678:stk500boot.c  **** 	boot_timer = 0;
 969               		.loc 1 678 0 discriminator 1
 970 0128 20E0      		ldi r18,0
 971 012a 30E0      		ldi r19,0
 972 012c 80E0      		ldi r24,0
 973               	.LVL57:
 974               	.L137:
 759:stk500boot.c  **** 		//*	main loop
 760:stk500boot.c  **** 		while (!isLeave) {
 761:stk500boot.c  **** 			/*
 762:stk500boot.c  **** 			 * Collect received bytes to a complete message
 763:stk500boot.c  **** 			 */
 764:stk500boot.c  **** 			msgParseState = ST_START;
 765:stk500boot.c  **** 			while (msgParseState != ST_PROCESS) {
 766:stk500boot.c  **** 				if (boot_state == 1) {
 975               		.loc 1 766 0
 976 012e 4130      		cpi r20,1
 977 0130 5105      		cpc r21,__zero_reg__
 978 0132 01F0      		breq .L188
 979               	.L147:
 980               	.LBB62:
 981               	.LBB63:
 982               	.LBB64:
 514:stk500boot.c  **** 			if (data != 0xffff) //*	make sure its valid before jumping to it.
 983               		.loc 1 514 0
 984 0134 40E0      		ldi r20,0
 985 0136 50E0      		ldi r21,0
 986 0138 BA01      		movw r22,r20
 987               	.L72:
 988               	.LVL58:
 989               	.LBE64:
 504:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE))) {
 990               		.loc 1 504 0
 991 013a 9091 C000 		lds r25,192
 992 013e 97FD      		sbrc r25,7
 993 0140 00C0      		rjmp .L188
 506:stk500boot.c  **** 		count++;
 994               		.loc 1 506 0
 995 0142 4F5F      		subi r20,-1
 996 0144 5F4F      		sbci r21,-1
 997 0146 6F4F      		sbci r22,-1
 998 0148 7F4F      		sbci r23,-1
 999               	.LVL59:
 507:stk500boot.c  **** 		if (count > MAX_TIME_COUNT) {
 1000               		.loc 1 507 0
 1001 014a 4130      		cpi r20,1
 1002 014c 92E1      		ldi r25,18
 1003 014e 5907      		cpc r21,r25
 1004 0150 9AE7      		ldi r25,122
 1005 0152 6907      		cpc r22,r25
 1006 0154 7105      		cpc r23,__zero_reg__
 1007 0156 00F0      		brlo .L72
 1008               	.LVL60:
 1009               	.LBB66:
 1010               	.LBB65:
 510:stk500boot.c  **** 			data = pgm_read_word_far(0); //*	get the first word of the user program
 1011               		.loc 1 510 0
 1012 0158 812C      		mov r8,__zero_reg__
 1013 015a 912C      		mov r9,__zero_reg__
 1014 015c 5401      		movw r10,r8
 1015               	/* #APP */
 1016               	 ;  510 "stk500boot.c" 1
 1017 015e ABBE      		out 59, r10
 1018 0160 F401      		movw r30, r8
 1019 0162 A791      		elpm r26, Z+
 1020 0164 B691      		elpm r27, Z
 1021               		
 1022               	 ;  0 "" 2
 1023               	.LVL61:
 1024               	/* #NOAPP */
 1025               	.LBE65:
 514:stk500boot.c  **** 			if (data != 0xffff) //*	make sure its valid before jumping to it.
 1026               		.loc 1 514 0
 1027 0166 1196      		adiw r26,1
 1028               	.LVL62:
 1029 0168 01F0      		breq .L147
 516:stk500boot.c  **** 				asm volatile(
 1030               		.loc 1 516 0
 1031               	/* #APP */
 1032               	 ;  516 "stk500boot.c" 1
 1033 016a EE27      		clr	r30		
 1034 016c FF27      		clr	r31		
 1035 016e 0994      		ijmp	
 1036               		
 1037               	 ;  0 "" 2
 1038               	/* #NOAPP */
 1039 0170 00C0      		rjmp .L147
 1040               	.LVL63:
 1041               	.L188:
 1042               	.LBE66:
 525:stk500boot.c  **** 	return UART_DATA_REG;
 1043               		.loc 1 525 0
 1044 0172 9091 C600 		lds r25,198
 1045               	.LVL64:
 1046               	.LBE63:
 1047               	.LBE62:
 767:stk500boot.c  **** 					boot_state = 0;
 768:stk500boot.c  **** 					c = UART_DATA_REG;
 769:stk500boot.c  **** 				} else {
 770:stk500boot.c  **** 					//	c	=	recchar();
 771:stk500boot.c  **** 					c = recchar_timeout();
 772:stk500boot.c  **** 
 773:stk500boot.c  **** 				}
 774:stk500boot.c  **** 
 775:stk500boot.c  **** #ifdef ENABLE_MONITOR
 776:stk500boot.c  **** 				rcvdCharCntr++;
 1048               		.loc 1 776 0
 1049 0176 CE5D      		subi r28,lo8(-290)
 1050 0178 DE4F      		sbci r29,hi8(-290)
 1051 017a 4881      		ld r20,Y
 1052 017c 5981      		ldd r21,Y+1
 1053 017e C252      		subi r28,lo8(290)
 1054 0180 D140      		sbci r29,hi8(290)
 1055 0182 4F5F      		subi r20,-1
 1056 0184 5F4F      		sbci r21,-1
 1057 0186 CE5D      		subi r28,lo8(-290)
 1058 0188 DE4F      		sbci r29,hi8(-290)
 1059 018a 5983      		std Y+1,r21
 1060 018c 4883      		st Y,r20
 1061 018e C252      		subi r28,lo8(290)
 1062 0190 D140      		sbci r29,hi8(290)
 1063               	.LVL65:
 777:stk500boot.c  **** 
 778:stk500boot.c  **** 				if ((c == '!') && (rcvdCharCntr < 10))
 1064               		.loc 1 778 0
 1065 0192 9132      		cpi r25,lo8(33)
 1066 0194 01F4      		brne .L149
 1067               		.loc 1 778 0 is_stmt 0 discriminator 1
 1068 0196 4A30      		cpi r20,10
 1069 0198 5105      		cpc r21,__zero_reg__
 1070 019a 00F4      		brsh .L149
 779:stk500boot.c  **** 				{
 780:stk500boot.c  **** 					exPointCntr++;
 1071               		.loc 1 780 0 is_stmt 1
 1072 019c C85D      		subi r28,lo8(-296)
 1073 019e DE4F      		sbci r29,hi8(-296)
 1074 01a0 4881      		ld r20,Y
 1075 01a2 5981      		ldd r21,Y+1
 1076 01a4 C852      		subi r28,lo8(296)
 1077 01a6 D140      		sbci r29,hi8(296)
 1078               	.LVL66:
 1079 01a8 4F5F      		subi r20,-1
 1080 01aa 5F4F      		sbci r21,-1
 1081 01ac C85D      		subi r28,lo8(-296)
 1082 01ae DE4F      		sbci r29,hi8(-296)
 1083 01b0 5983      		std Y+1,r21
 1084 01b2 4883      		st Y,r20
 1085 01b4 C852      		subi r28,lo8(296)
 1086 01b6 D140      		sbci r29,hi8(296)
 1087               	.LVL67:
 781:stk500boot.c  **** 					if (exPointCntr == 3)
 1088               		.loc 1 781 0
 1089 01b8 4330      		cpi r20,3
 1090 01ba 5105      		cpc r21,__zero_reg__
 1091 01bc 01F4      		brne .L76
 1092 01be 00C0      		rjmp .L199
 1093               	.LVL68:
 1094               	.L149:
 782:stk500boot.c  **** 					{
 783:stk500boot.c  **** 						exPointCntr = 0; //	reset back to zero so we dont get in an endless loop
 784:stk500boot.c  **** 						isLeave = 1;
 785:stk500boot.c  **** 						msgParseState = 99;//*	we dont want it do anything
 786:stk500boot.c  **** 						break;
 787:stk500boot.c  **** 					}
 788:stk500boot.c  **** 				}
 789:stk500boot.c  **** 				else
 790:stk500boot.c  **** 				{
 791:stk500boot.c  **** 					exPointCntr = 0;
 1095               		.loc 1 791 0
 1096 01c0 C85D      		subi r28,lo8(-296)
 1097 01c2 DE4F      		sbci r29,hi8(-296)
 1098 01c4 1982      		std Y+1,__zero_reg__
 1099 01c6 1882      		st Y,__zero_reg__
 1100 01c8 C852      		subi r28,lo8(296)
 1101 01ca D140      		sbci r29,hi8(296)
 1102               	.LVL69:
 1103               	.L76:
 792:stk500boot.c  **** 				}
 793:stk500boot.c  **** #endif
 794:stk500boot.c  **** 
 795:stk500boot.c  **** 				switch (msgParseState) {
 1104               		.loc 1 795 0
 1105 01cc 8330      		cpi r24,lo8(3)
 1106 01ce 01F0      		breq .L79
 1107 01d0 00F4      		brsh .L80
 1108 01d2 8130      		cpi r24,lo8(1)
 1109 01d4 01F0      		breq .L81
 1110 01d6 00F0      		brlo .L186
 1111 01d8 00C0      		rjmp .L200
 1112               	.L80:
 1113 01da 8530      		cpi r24,lo8(5)
 1114 01dc 01F0      		breq .L84
 1115 01de 00F0      		brlo .L85
 1116 01e0 8630      		cpi r24,lo8(6)
 1117 01e2 01F4      		brne .+2
 1118 01e4 00C0      		rjmp .L86
 1119 01e6 00C0      		rjmp .L201
 1120               	.L186:
 796:stk500boot.c  **** 				case ST_START:
 797:stk500boot.c  **** 					if (c == MESSAGE_START) {
 1121               		.loc 1 797 0
 1122 01e8 9B31      		cpi r25,lo8(27)
 1123 01ea 01F4      		brne .+2
 1124 01ec 00C0      		rjmp .L202
 1125               	.LVL70:
 1126               	.L88:
 1127 01ee 40E0      		ldi r20,0
 1128 01f0 50E0      		ldi r21,0
 1129 01f2 00C0      		rjmp .L137
 1130               	.LVL71:
 1131               	.L81:
 798:stk500boot.c  **** 						msgParseState = ST_GET_SEQ_NUM;
 799:stk500boot.c  **** 						checksum = MESSAGE_START ^ 0;
 800:stk500boot.c  **** 					}
 801:stk500boot.c  **** 					break;
 802:stk500boot.c  **** 
 803:stk500boot.c  **** 				case ST_GET_SEQ_NUM:
 804:stk500boot.c  **** #ifdef _FIX_ISSUE_505_
 805:stk500boot.c  **** 					seqNum = c;
 806:stk500boot.c  **** 					msgParseState = ST_MSG_SIZE_1;
 807:stk500boot.c  **** 					checksum ^= c;
 1132               		.loc 1 807 0
 1133 01f4 3926      		eor r3,r25
 1134               	.LVL72:
 808:stk500boot.c  **** #else
 809:stk500boot.c  **** 					if ( (c == 1) || (c == seqNum) )
 810:stk500boot.c  **** 					{
 811:stk500boot.c  **** 						seqNum = c;
 812:stk500boot.c  **** 						msgParseState = ST_MSG_SIZE_1;
 813:stk500boot.c  **** 						checksum ^= c;
 814:stk500boot.c  **** 					}
 815:stk500boot.c  **** 					else
 816:stk500boot.c  **** 					{
 817:stk500boot.c  **** 						msgParseState = ST_START;
 818:stk500boot.c  **** 					}
 819:stk500boot.c  **** #endif
 820:stk500boot.c  **** 					break;
 1135               		.loc 1 820 0
 1136 01f6 C05E      		subi r28,lo8(-288)
 1137 01f8 DE4F      		sbci r29,hi8(-288)
 1138 01fa 9883      		st Y,r25
 1139 01fc C052      		subi r28,lo8(288)
 1140 01fe D140      		sbci r29,hi8(288)
 806:stk500boot.c  **** 					msgParseState = ST_MSG_SIZE_1;
 1141               		.loc 1 806 0
 1142 0200 82E0      		ldi r24,lo8(2)
 1143               		.loc 1 820 0
 1144 0202 00C0      		rjmp .L88
 1145               	.LVL73:
 1146               	.L200:
 821:stk500boot.c  **** 
 822:stk500boot.c  **** 				case ST_MSG_SIZE_1:
 823:stk500boot.c  **** 					msgLength = c << 8;
 1147               		.loc 1 823 0
 1148 0204 292F      		mov r18,r25
 1149               	.LVL74:
 1150 0206 30E0      		ldi r19,0
 1151 0208 322F      		mov r19,r18
 1152 020a 2227      		clr r18
 1153               	.LVL75:
 824:stk500boot.c  **** 					msgParseState = ST_MSG_SIZE_2;
 825:stk500boot.c  **** 					checksum ^= c;
 1154               		.loc 1 825 0
 1155 020c 3926      		eor r3,r25
 1156               	.LVL76:
 824:stk500boot.c  **** 					msgParseState = ST_MSG_SIZE_2;
 1157               		.loc 1 824 0
 1158 020e 83E0      		ldi r24,lo8(3)
 826:stk500boot.c  **** 					break;
 1159               		.loc 1 826 0
 1160 0210 00C0      		rjmp .L88
 1161               	.LVL77:
 1162               	.L79:
 827:stk500boot.c  **** 
 828:stk500boot.c  **** 				case ST_MSG_SIZE_2:
 829:stk500boot.c  **** 					msgLength |= c;
 1163               		.loc 1 829 0
 1164 0212 292B      		or r18,r25
 1165               	.LVL78:
 830:stk500boot.c  **** 					msgParseState = ST_GET_TOKEN;
 831:stk500boot.c  **** 					checksum ^= c;
 1166               		.loc 1 831 0
 1167 0214 3926      		eor r3,r25
 1168               	.LVL79:
 830:stk500boot.c  **** 					msgParseState = ST_GET_TOKEN;
 1169               		.loc 1 830 0
 1170 0216 84E0      		ldi r24,lo8(4)
 832:stk500boot.c  **** 					break;
 1171               		.loc 1 832 0
 1172 0218 00C0      		rjmp .L88
 1173               	.LVL80:
 1174               	.L85:
 833:stk500boot.c  **** 
 834:stk500boot.c  **** 				case ST_GET_TOKEN:
 835:stk500boot.c  **** 					if (c == TOKEN) {
 1175               		.loc 1 835 0
 1176 021a 9E30      		cpi r25,lo8(14)
 1177 021c 01F0      		breq .+2
 1178 021e 00C0      		rjmp .L152
 1179               	.LVL81:
 836:stk500boot.c  **** 						msgParseState = ST_GET_DATA;
 837:stk500boot.c  **** 						checksum ^= c;
 1180               		.loc 1 837 0
 1181 0220 3926      		eor r3,r25
 1182               	.LVL82:
 838:stk500boot.c  **** 						ii = 0;
 1183               		.loc 1 838 0
 1184 0222 C25E      		subi r28,lo8(-286)
 1185 0224 DE4F      		sbci r29,hi8(-286)
 1186 0226 1982      		std Y+1,__zero_reg__
 1187 0228 1882      		st Y,__zero_reg__
 1188 022a CE51      		subi r28,lo8(286)
 1189 022c D140      		sbci r29,hi8(286)
 836:stk500boot.c  **** 						msgParseState = ST_GET_DATA;
 1190               		.loc 1 836 0
 1191 022e 85E0      		ldi r24,lo8(5)
 1192 0230 00C0      		rjmp .L88
 1193               	.LVL83:
 1194               	.L84:
 839:stk500boot.c  **** 					} else {
 840:stk500boot.c  **** 						msgParseState = ST_START;
 841:stk500boot.c  **** 					}
 842:stk500boot.c  **** 					break;
 843:stk500boot.c  **** 
 844:stk500boot.c  **** 				case ST_GET_DATA:
 845:stk500boot.c  **** 					msgBuffer[ii++] = c;
 1195               		.loc 1 845 0
 1196 0232 C25E      		subi r28,lo8(-286)
 1197 0234 DE4F      		sbci r29,hi8(-286)
 1198 0236 4881      		ld r20,Y
 1199 0238 5981      		ldd r21,Y+1
 1200 023a CE51      		subi r28,lo8(286)
 1201 023c D140      		sbci r29,hi8(286)
 1202 023e 4F5F      		subi r20,-1
 1203 0240 5F4F      		sbci r21,-1
 1204               	.LVL84:
 1205 0242 E1E0      		ldi r30,lo8(1)
 1206 0244 F0E0      		ldi r31,0
 1207 0246 EC0F      		add r30,r28
 1208 0248 FD1F      		adc r31,r29
 1209 024a C25E      		subi r28,lo8(-286)
 1210 024c DE4F      		sbci r29,hi8(-286)
 1211 024e 8880      		ld r8,Y
 1212 0250 9980      		ldd r9,Y+1
 1213 0252 CE51      		subi r28,lo8(286)
 1214 0254 D140      		sbci r29,hi8(286)
 1215 0256 E80D      		add r30,r8
 1216 0258 F91D      		adc r31,r9
 1217 025a 9083      		st Z,r25
 846:stk500boot.c  **** 					checksum ^= c;
 1218               		.loc 1 846 0
 1219 025c 3926      		eor r3,r25
 1220               	.LVL85:
 847:stk500boot.c  **** 					if (ii == msgLength) {
 1221               		.loc 1 847 0
 1222 025e 4217      		cp r20,r18
 1223 0260 5307      		cpc r21,r19
 1224 0262 01F4      		brne .+2
 1225 0264 00C0      		rjmp .L153
 1226 0266 C25E      		subi r28,lo8(-286)
 1227 0268 DE4F      		sbci r29,hi8(-286)
 1228 026a 5983      		std Y+1,r21
 1229 026c 4883      		st Y,r20
 1230 026e CE51      		subi r28,lo8(286)
 1231 0270 D140      		sbci r29,hi8(286)
 1232 0272 00C0      		rjmp .L88
 1233               	.LVL86:
 1234               	.L86:
 848:stk500boot.c  **** 						msgParseState = ST_GET_CHECK;
 849:stk500boot.c  **** 					}
 850:stk500boot.c  **** 					break;
 851:stk500boot.c  **** 
 852:stk500boot.c  **** 				case ST_GET_CHECK:
 853:stk500boot.c  **** 					if (c == checksum) {
 1235               		.loc 1 853 0
 1236 0274 9311      		cpse r25,r3
 1237 0276 00C0      		rjmp .L152
 1238 0278 00C0      		rjmp .L154
 1239               	.L201:
 1240               	.LVL87:
 765:stk500boot.c  **** 			while (msgParseState != ST_PROCESS) {
 1241               		.loc 1 765 0 discriminator 1
 1242 027a 8730      		cpi r24,lo8(7)
 1243 027c 01F0      		breq .+2
 1244 027e 00C0      		rjmp .L88
 1245 0280 00C0      		rjmp .L154
 1246               	.LVL88:
 1247               	.L199:
 783:stk500boot.c  **** 						exPointCntr = 0; //	reset back to zero so we dont get in an endless loop
 1248               		.loc 1 783 0
 1249 0282 C85D      		subi r28,lo8(-296)
 1250 0284 DE4F      		sbci r29,hi8(-296)
 1251 0286 1982      		std Y+1,__zero_reg__
 1252 0288 1882      		st Y,__zero_reg__
 1253 028a C852      		subi r28,lo8(296)
 1254 028c D140      		sbci r29,hi8(296)
 784:stk500boot.c  **** 						isLeave = 1;
 1255               		.loc 1 784 0
 1256 028e 21E0      		ldi r18,lo8(1)
 1257               	.LVL89:
 1258 0290 CF5D      		subi r28,lo8(-289)
 1259 0292 DE4F      		sbci r29,hi8(-289)
 1260 0294 2883      		st Y,r18
 1261 0296 C152      		subi r28,lo8(289)
 1262 0298 D140      		sbci r29,hi8(289)
 1263 029a 00C0      		rjmp .L77
 1264               	.LVL90:
 1265               	.L154:
 1266 029c CF5D      		subi r28,lo8(-289)
 1267 029e DE4F      		sbci r29,hi8(-289)
 1268 02a0 1882      		st Y,__zero_reg__
 1269 02a2 C152      		subi r28,lo8(289)
 1270 02a4 D140      		sbci r29,hi8(289)
 1271               	.LVL91:
 1272               	.L77:
 854:stk500boot.c  **** 						msgParseState = ST_PROCESS;
 855:stk500boot.c  **** 					} else {
 856:stk500boot.c  **** 						msgParseState = ST_START;
 857:stk500boot.c  **** 					}
 858:stk500boot.c  **** 					break;
 859:stk500boot.c  **** 				} //	switch
 860:stk500boot.c  **** 			} //	while(msgParseState)
 861:stk500boot.c  **** 
 862:stk500boot.c  **** 			/*
 863:stk500boot.c  **** 			 * Now process the STK500 commands, see Atmel Appnote AVR068
 864:stk500boot.c  **** 			 */
 865:stk500boot.c  **** 
 866:stk500boot.c  **** 			switch (msgBuffer[0]) {
 1273               		.loc 1 866 0
 1274 02a6 2981      		ldd r18,Y+1
 1275 02a8 2331      		cpi r18,lo8(19)
 1276 02aa 01F4      		brne .+2
 1277 02ac 00C0      		rjmp .L90
 1278 02ae 00F4      		brsh .L91
 1279 02b0 2630      		cpi r18,lo8(6)
 1280 02b2 01F4      		brne .+2
 1281 02b4 00C0      		rjmp .L92
 1282 02b6 00F4      		brsh .L93
 1283 02b8 2230      		cpi r18,lo8(2)
 1284 02ba 01F4      		brne .+2
 1285 02bc 00C0      		rjmp .L197
 1286 02be 2330      		cpi r18,lo8(3)
 1287 02c0 01F4      		brne .+2
 1288 02c2 00C0      		rjmp .L95
 1289 02c4 2130      		cpi r18,lo8(1)
 1290 02c6 01F0      		breq .+2
 1291 02c8 00C0      		rjmp .L89
 1292               	.LVL92:
 867:stk500boot.c  **** #ifndef REMOVE_CMD_SPI_MULTI
 868:stk500boot.c  **** 			case CMD_SPI_MULTI: {
 869:stk500boot.c  **** 				unsigned char answerByte;
 870:stk500boot.c  **** 				unsigned char flag = 0;
 871:stk500boot.c  **** 
 872:stk500boot.c  **** 				if (msgBuffer[4] == 0x30) {
 873:stk500boot.c  **** 					unsigned char signatureIndex = msgBuffer[6];
 874:stk500boot.c  **** 
 875:stk500boot.c  **** 					if (signatureIndex == 0) {
 876:stk500boot.c  **** 						answerByte = (SIGNATURE_BYTES >> 16) & 0x000000FF;
 877:stk500boot.c  **** 					} else if (signatureIndex == 1) {
 878:stk500boot.c  **** 						answerByte = (SIGNATURE_BYTES >> 8) & 0x000000FF;
 879:stk500boot.c  **** 					} else {
 880:stk500boot.c  **** 						answerByte = SIGNATURE_BYTES & 0x000000FF;
 881:stk500boot.c  **** 					}
 882:stk500boot.c  **** 				} else if (msgBuffer[4] & 0x50) {
 883:stk500boot.c  **** 					//*	Issue 544: 	stk500v2 bootloader doesn't support reading fuses
 884:stk500boot.c  **** 					//*	I cant find the docs that say what these are supposed to be but this was figured out by tr
 885:stk500boot.c  **** 					//	answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 886:stk500boot.c  **** 					//	answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 887:stk500boot.c  **** 					//	answerByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 888:stk500boot.c  **** 					if (msgBuffer[4] == 0x50) {
 889:stk500boot.c  **** 						answerByte = boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 890:stk500boot.c  **** 					} else if (msgBuffer[4] == 0x58) {
 891:stk500boot.c  **** 						answerByte = boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 892:stk500boot.c  **** 					} else {
 893:stk500boot.c  **** 						answerByte = 0;
 894:stk500boot.c  **** 					}
 895:stk500boot.c  **** 				} else {
 896:stk500boot.c  **** 					answerByte = 0; // for all others command are not implemented, return dummy value for AVRDUDE 
 897:stk500boot.c  **** 				}
 898:stk500boot.c  **** 				if (!flag) {
 899:stk500boot.c  **** 					msgLength = 7;
 900:stk500boot.c  **** 					msgBuffer[1] = STATUS_CMD_OK;
 901:stk500boot.c  **** 					msgBuffer[2] = 0;
 902:stk500boot.c  **** 					msgBuffer[3] = msgBuffer[4];
 903:stk500boot.c  **** 					msgBuffer[4] = 0;
 904:stk500boot.c  **** 					msgBuffer[5] = answerByte;
 905:stk500boot.c  **** 					msgBuffer[6] = STATUS_CMD_OK;
 906:stk500boot.c  **** 				}
 907:stk500boot.c  **** 			}
 908:stk500boot.c  **** 				break;
 909:stk500boot.c  **** #endif
 910:stk500boot.c  **** 			case CMD_SIGN_ON:
 911:stk500boot.c  **** 				msgLength = 11;
 912:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1293               		.loc 1 912 0
 1294 02ca 1A82      		std Y+2,__zero_reg__
 913:stk500boot.c  **** 				msgBuffer[2] = 8;
 1295               		.loc 1 913 0
 1296 02cc 88E0      		ldi r24,lo8(8)
 1297               	.LVL93:
 1298 02ce 8B83      		std Y+3,r24
 914:stk500boot.c  **** 				msgBuffer[3] = 'A';
 1299               		.loc 1 914 0
 1300 02d0 81E4      		ldi r24,lo8(65)
 1301 02d2 8C83      		std Y+4,r24
 915:stk500boot.c  **** 				msgBuffer[4] = 'V';
 1302               		.loc 1 915 0
 1303 02d4 86E5      		ldi r24,lo8(86)
 1304 02d6 8D83      		std Y+5,r24
 916:stk500boot.c  **** 				msgBuffer[5] = 'R';
 1305               		.loc 1 916 0
 1306 02d8 82E5      		ldi r24,lo8(82)
 1307 02da 8E83      		std Y+6,r24
 917:stk500boot.c  **** 				msgBuffer[6] = 'I';
 1308               		.loc 1 917 0
 1309 02dc 89E4      		ldi r24,lo8(73)
 1310 02de 8F83      		std Y+7,r24
 918:stk500boot.c  **** 				msgBuffer[7] = 'S';
 1311               		.loc 1 918 0
 1312 02e0 83E5      		ldi r24,lo8(83)
 1313 02e2 8887      		std Y+8,r24
 919:stk500boot.c  **** 				msgBuffer[8] = 'P';
 1314               		.loc 1 919 0
 1315 02e4 80E5      		ldi r24,lo8(80)
 1316 02e6 8987      		std Y+9,r24
 920:stk500boot.c  **** 				msgBuffer[9] = '_';
 1317               		.loc 1 920 0
 1318 02e8 8FE5      		ldi r24,lo8(95)
 1319 02ea 8A87      		std Y+10,r24
 921:stk500boot.c  **** 				msgBuffer[10] = '2';
 1320               		.loc 1 921 0
 1321 02ec 82E3      		ldi r24,lo8(50)
 1322 02ee 8B87      		std Y+11,r24
 911:stk500boot.c  **** 				msgLength = 11;
 1323               		.loc 1 911 0
 1324 02f0 0BE0      		ldi r16,lo8(11)
 1325 02f2 10E0      		ldi r17,0
 922:stk500boot.c  **** 				break;
 1326               		.loc 1 922 0
 1327 02f4 00C0      		rjmp .L109
 1328               	.LVL94:
 1329               	.L93:
 866:stk500boot.c  **** 			switch (msgBuffer[0]) {
 1330               		.loc 1 866 0
 1331 02f6 2131      		cpi r18,lo8(17)
 1332 02f8 01F4      		brne .+2
 1333 02fa 00C0      		rjmp .L155
 1334 02fc 00F0      		brlo .+2
 1335 02fe 00C0      		rjmp .L98
 1336 0300 2031      		cpi r18,lo8(16)
 1337 0302 01F4      		brne .+2
 1338 0304 00C0      		rjmp .L197
 1339 0306 00C0      		rjmp .L89
 1340               	.L91:
 1341 0308 2831      		cpi r18,lo8(24)
 1342 030a 01F4      		brne .+2
 1343 030c 00C0      		rjmp .L99
 1344 030e 00F4      		brsh .L100
 1345 0310 2531      		cpi r18,lo8(21)
 1346 0312 01F4      		brne .+2
 1347 0314 00C0      		rjmp .L90
 1348 0316 00F4      		brsh .+2
 1349 0318 00C0      		rjmp .L101
 1350 031a 2631      		cpi r18,lo8(22)
 1351 031c 01F4      		brne .+2
 1352 031e 00C0      		rjmp .L101
 1353 0320 00C0      		rjmp .L89
 1354               	.L100:
 1355 0322 2A31      		cpi r18,lo8(26)
 1356 0324 01F4      		brne .+2
 1357 0326 00C0      		rjmp .L102
 1358 0328 00F4      		brsh .+2
 1359 032a 00C0      		rjmp .L103
 1360 032c 2B31      		cpi r18,lo8(27)
 1361 032e 01F4      		brne .+2
 1362 0330 00C0      		rjmp .L104
 1363 0332 2D31      		cpi r18,lo8(29)
 1364 0334 01F0      		breq .+2
 1365 0336 00C0      		rjmp .L89
 1366               	.LVL95:
 1367               	.LBB67:
 872:stk500boot.c  **** 				if (msgBuffer[4] == 0x30) {
 1368               		.loc 1 872 0
 1369 0338 8D81      		ldd r24,Y+5
 1370               	.LVL96:
 1371 033a 8033      		cpi r24,lo8(48)
 1372 033c 01F4      		brne .L106
 1373               	.LBB68:
 873:stk500boot.c  **** 					unsigned char signatureIndex = msgBuffer[6];
 1374               		.loc 1 873 0
 1375 033e 9F81      		ldd r25,Y+7
 1376               	.LVL97:
 875:stk500boot.c  **** 					if (signatureIndex == 0) {
 1377               		.loc 1 875 0
 1378 0340 9923      		tst r25
 1379 0342 01F0      		breq .L156
 877:stk500boot.c  **** 					} else if (signatureIndex == 1) {
 1380               		.loc 1 877 0
 1381 0344 9130      		cpi r25,lo8(1)
 1382 0346 01F4      		brne .L157
 878:stk500boot.c  **** 						answerByte = (SIGNATURE_BYTES >> 8) & 0x000000FF;
 1383               		.loc 1 878 0
 1384 0348 98E9      		ldi r25,lo8(-104)
 1385               	.LVL98:
 1386 034a 00C0      		rjmp .L107
 1387               	.LVL99:
 1388               	.L106:
 1389               	.LBE68:
 882:stk500boot.c  **** 				} else if (msgBuffer[4] & 0x50) {
 1390               		.loc 1 882 0
 1391 034c 982F      		mov r25,r24
 1392               	.LVL100:
 1393 034e 9075      		andi r25,lo8(80)
 1394 0350 01F0      		breq .L159
 888:stk500boot.c  **** 					if (msgBuffer[4] == 0x50) {
 1395               		.loc 1 888 0
 1396 0352 8035      		cpi r24,lo8(80)
 1397 0354 01F4      		brne .L108
 1398               	.LBB69:
 889:stk500boot.c  **** 						answerByte = boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 1399               		.loc 1 889 0
 1400 0356 99E0      		ldi r25,lo8(9)
 1401 0358 E0E0      		ldi r30,0
 1402 035a F0E0      		ldi r31,0
 1403 035c 00C0      		rjmp .L189
 1404               	.L108:
 1405               	.LBE69:
 890:stk500boot.c  **** 					} else if (msgBuffer[4] == 0x58) {
 1406               		.loc 1 890 0
 1407 035e 8835      		cpi r24,lo8(88)
 1408 0360 01F4      		brne .L159
 1409               	.LBB70:
 891:stk500boot.c  **** 						answerByte = boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 1410               		.loc 1 891 0
 1411 0362 E3E0      		ldi r30,lo8(3)
 1412 0364 F0E0      		ldi r31,0
 1413 0366 99E0      		ldi r25,lo8(9)
 1414               	.L189:
 1415               	/* #APP */
 1416               	 ;  891 "stk500boot.c" 1
 1417 0368 9093 5700 		sts 87, r25
 1418 036c 9491      		lpm r25, Z
 1419               		
 1420               	 ;  0 "" 2
 1421               	.LVL101:
 1422               	/* #NOAPP */
 1423               	.LBE70:
 1424 036e 00C0      		rjmp .L107
 1425               	.LVL102:
 1426               	.L156:
 1427               	.LBB71:
 876:stk500boot.c  **** 						answerByte = (SIGNATURE_BYTES >> 16) & 0x000000FF;
 1428               		.loc 1 876 0
 1429 0370 9EE1      		ldi r25,lo8(30)
 1430               	.LVL103:
 1431 0372 00C0      		rjmp .L107
 1432               	.LVL104:
 1433               	.L157:
 880:stk500boot.c  **** 						answerByte = SIGNATURE_BYTES & 0x000000FF;
 1434               		.loc 1 880 0
 1435 0374 91E0      		ldi r25,lo8(1)
 1436               	.LVL105:
 1437 0376 00C0      		rjmp .L107
 1438               	.LVL106:
 1439               	.L159:
 1440               	.LBE71:
 896:stk500boot.c  **** 					answerByte = 0; // for all others command are not implemented, return dummy value for AVRDUDE 
 1441               		.loc 1 896 0
 1442 0378 90E0      		ldi r25,0
 1443               	.L107:
 1444               	.LVL107:
 900:stk500boot.c  **** 					msgBuffer[1] = STATUS_CMD_OK;
 1445               		.loc 1 900 0
 1446 037a 1A82      		std Y+2,__zero_reg__
 901:stk500boot.c  **** 					msgBuffer[2] = 0;
 1447               		.loc 1 901 0
 1448 037c 1B82      		std Y+3,__zero_reg__
 902:stk500boot.c  **** 					msgBuffer[3] = msgBuffer[4];
 1449               		.loc 1 902 0
 1450 037e 8C83      		std Y+4,r24
 903:stk500boot.c  **** 					msgBuffer[4] = 0;
 1451               		.loc 1 903 0
 1452 0380 1D82      		std Y+5,__zero_reg__
 904:stk500boot.c  **** 					msgBuffer[5] = answerByte;
 1453               		.loc 1 904 0
 1454 0382 9E83      		std Y+6,r25
 905:stk500boot.c  **** 					msgBuffer[6] = STATUS_CMD_OK;
 1455               		.loc 1 905 0
 1456 0384 1F82      		std Y+7,__zero_reg__
 899:stk500boot.c  **** 					msgLength = 7;
 1457               		.loc 1 899 0
 1458 0386 07E0      		ldi r16,lo8(7)
 1459 0388 10E0      		ldi r17,0
 1460 038a 00C0      		rjmp .L109
 1461               	.LVL108:
 1462               	.L95:
 1463 038c EA81      		ldd r30,Y+2
 1464 038e E059      		subi r30,lo8(-(112))
 1465 0390 E330      		cpi r30,lo8(3)
 1466 0392 00F4      		brsh .L160
 1467 0394 F0E0      		ldi r31,0
 1468 0396 E050      		subi r30,lo8(-(CSWTCH.43))
 1469 0398 F040      		sbci r31,hi8(-(CSWTCH.43))
 1470 039a 8081      		ld r24,Z
 1471               	.LVL109:
 1472 039c 00C0      		rjmp .L110
 1473               	.LVL110:
 1474               	.L160:
 1475               	.LBE67:
 1476               	.LBB72:
 923:stk500boot.c  **** 
 924:stk500boot.c  **** 			case CMD_GET_PARAMETER: {
 925:stk500boot.c  **** 				unsigned char value;
 926:stk500boot.c  **** 
 927:stk500boot.c  **** 				switch (msgBuffer[1]) {
 1477               		.loc 1 927 0
 1478 039e 80E0      		ldi r24,0
 1479               	.LVL111:
 1480               	.L110:
 928:stk500boot.c  **** 				case PARAM_BUILD_NUMBER_LOW:
 929:stk500boot.c  **** 					value = CONFIG_PARAM_BUILD_NUMBER_LOW;
 930:stk500boot.c  **** 					break;
 931:stk500boot.c  **** 				case PARAM_BUILD_NUMBER_HIGH:
 932:stk500boot.c  **** 					value = CONFIG_PARAM_BUILD_NUMBER_HIGH;
 933:stk500boot.c  **** 					break;
 934:stk500boot.c  **** 				case PARAM_HW_VER:
 935:stk500boot.c  **** 					value = CONFIG_PARAM_HW_VER;
 936:stk500boot.c  **** 					break;
 937:stk500boot.c  **** 				case PARAM_SW_MAJOR:
 938:stk500boot.c  **** 					value = CONFIG_PARAM_SW_MAJOR;
 939:stk500boot.c  **** 					break;
 940:stk500boot.c  **** 				case PARAM_SW_MINOR:
 941:stk500boot.c  **** 					value = CONFIG_PARAM_SW_MINOR;
 942:stk500boot.c  **** 					break;
 943:stk500boot.c  **** 				default:
 944:stk500boot.c  **** 					value = 0;
 945:stk500boot.c  **** 					break;
 946:stk500boot.c  **** 				}
 947:stk500boot.c  **** 				msgLength = 3;
 948:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1481               		.loc 1 948 0
 1482 03a0 1A82      		std Y+2,__zero_reg__
 949:stk500boot.c  **** 				msgBuffer[2] = value;
 1483               		.loc 1 949 0
 1484 03a2 8B83      		std Y+3,r24
 1485 03a4 00C0      		rjmp .L192
 1486               	.LVL112:
 1487               	.L155:
 1488               	.LBE72:
 950:stk500boot.c  **** 			}
 951:stk500boot.c  **** 				break;
 952:stk500boot.c  **** 
 953:stk500boot.c  **** 			case CMD_LEAVE_PROGMODE_ISP:
 954:stk500boot.c  **** 				isLeave = 1;
 1489               		.loc 1 954 0
 1490 03a6 21E0      		ldi r18,lo8(1)
 1491 03a8 CF5D      		subi r28,lo8(-289)
 1492 03aa DE4F      		sbci r29,hi8(-289)
 1493 03ac 2883      		st Y,r18
 1494 03ae C152      		subi r28,lo8(289)
 1495 03b0 D140      		sbci r29,hi8(289)
 1496               	.LVL113:
 1497 03b2 00C0      		rjmp .L197
 1498               	.LVL114:
 1499               	.L104:
 1500               	.LBB73:
 955:stk500boot.c  **** 				//*	fall thru
 956:stk500boot.c  **** 
 957:stk500boot.c  **** 			case CMD_SET_PARAMETER:
 958:stk500boot.c  **** 			case CMD_ENTER_PROGMODE_ISP:
 959:stk500boot.c  **** 				msgLength = 2;
 960:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 961:stk500boot.c  **** 				break;
 962:stk500boot.c  **** 
 963:stk500boot.c  **** 			case CMD_READ_SIGNATURE_ISP: {
 964:stk500boot.c  **** 				unsigned char signatureIndex = msgBuffer[4];
 1501               		.loc 1 964 0
 1502 03b4 8D81      		ldd r24,Y+5
 1503               	.LVL115:
 965:stk500boot.c  **** 				unsigned char signature;
 966:stk500boot.c  **** 
 967:stk500boot.c  **** 				if (signatureIndex == 0)
 1504               		.loc 1 967 0
 1505 03b6 8823      		tst r24
 1506 03b8 01F0      		breq .L161
 968:stk500boot.c  **** 					signature = (SIGNATURE_BYTES >> 16) & 0x000000FF;
 969:stk500boot.c  **** 				else if (signatureIndex == 1)
 1507               		.loc 1 969 0
 1508 03ba 8130      		cpi r24,lo8(1)
 1509 03bc 01F4      		brne .L162
 970:stk500boot.c  **** 					signature = (SIGNATURE_BYTES >> 8) & 0x000000FF;
 1510               		.loc 1 970 0
 1511 03be 88E9      		ldi r24,lo8(-104)
 1512               	.LVL116:
 1513 03c0 00C0      		rjmp .L196
 1514               	.LVL117:
 1515               	.L161:
 968:stk500boot.c  **** 					signature = (SIGNATURE_BYTES >> 16) & 0x000000FF;
 1516               		.loc 1 968 0
 1517 03c2 8EE1      		ldi r24,lo8(30)
 1518               	.LVL118:
 1519 03c4 00C0      		rjmp .L196
 1520               	.LVL119:
 1521               	.L162:
 971:stk500boot.c  **** 				else
 972:stk500boot.c  **** 					signature = SIGNATURE_BYTES & 0x000000FF;
 1522               		.loc 1 972 0
 1523 03c6 81E0      		ldi r24,lo8(1)
 1524               	.LVL120:
 1525 03c8 00C0      		rjmp .L196
 1526               	.LVL121:
 1527               	.L102:
 1528               	.LBE73:
 973:stk500boot.c  **** 
 974:stk500boot.c  **** 				msgLength = 4;
 975:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 976:stk500boot.c  **** 				msgBuffer[2] = signature;
 977:stk500boot.c  **** 				msgBuffer[3] = STATUS_CMD_OK;
 978:stk500boot.c  **** 			}
 979:stk500boot.c  **** 				break;
 980:stk500boot.c  **** 
 981:stk500boot.c  **** 			case CMD_READ_LOCK_ISP:
 982:stk500boot.c  **** 				msgLength = 4;
 983:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1529               		.loc 1 983 0
 1530 03ca 1A82      		std Y+2,__zero_reg__
 1531               	.LBB74:
 984:stk500boot.c  **** 				msgBuffer[2] = boot_lock_fuse_bits_get( GET_LOCK_BITS );
 1532               		.loc 1 984 0
 1533 03cc E1E0      		ldi r30,lo8(1)
 1534 03ce F0E0      		ldi r31,0
 1535 03d0 89E0      		ldi r24,lo8(9)
 1536               	.LVL122:
 1537               	/* #APP */
 1538               	 ;  984 "stk500boot.c" 1
 1539 03d2 8093 5700 		sts 87, r24
 1540 03d6 E491      		lpm r30, Z
 1541               		
 1542               	 ;  0 "" 2
 1543               	.LVL123:
 1544               	/* #NOAPP */
 1545               	.LBE74:
 1546 03d8 EB83      		std Y+3,r30
 1547               	.LVL124:
 1548               	.L194:
 985:stk500boot.c  **** 				msgBuffer[3] = STATUS_CMD_OK;
 1549               		.loc 1 985 0
 1550 03da 1C82      		std Y+4,__zero_reg__
 982:stk500boot.c  **** 				msgLength = 4;
 1551               		.loc 1 982 0
 1552 03dc 04E0      		ldi r16,lo8(4)
 1553 03de 10E0      		ldi r17,0
 986:stk500boot.c  **** 				break;
 1554               		.loc 1 986 0
 1555 03e0 00C0      		rjmp .L109
 1556               	.LVL125:
 1557               	.L99:
 1558               	.LBB75:
 987:stk500boot.c  **** 
 988:stk500boot.c  **** 			case CMD_READ_FUSE_ISP: {
 989:stk500boot.c  **** 				unsigned char fuseBits;
 990:stk500boot.c  **** 
 991:stk500boot.c  **** 				if (msgBuffer[2] == 0x50) {
 1559               		.loc 1 991 0
 1560 03e2 8B81      		ldd r24,Y+3
 1561               	.LVL126:
 1562 03e4 8035      		cpi r24,lo8(80)
 1563 03e6 01F4      		brne .L112
 992:stk500boot.c  **** 					if (msgBuffer[3] == 0x08)
 1564               		.loc 1 992 0
 1565 03e8 8C81      		ldd r24,Y+4
 1566 03ea 8830      		cpi r24,lo8(8)
 1567 03ec 01F4      		brne .L113
 1568               	.LBB76:
 993:stk500boot.c  **** 						fuseBits = boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 1569               		.loc 1 993 0
 1570 03ee E2E0      		ldi r30,lo8(2)
 1571 03f0 F0E0      		ldi r31,0
 1572 03f2 00C0      		rjmp .L190
 1573               	.L113:
 1574               	.LBE76:
 1575               	.LBB77:
 994:stk500boot.c  **** 					else
 995:stk500boot.c  **** 						fuseBits = boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
 1576               		.loc 1 995 0
 1577 03f4 89E0      		ldi r24,lo8(9)
 1578 03f6 E0E0      		ldi r30,0
 1579 03f8 F0E0      		ldi r31,0
 1580 03fa 00C0      		rjmp .L191
 1581               	.L112:
 1582               	.LBE77:
 1583               	.LBB78:
 996:stk500boot.c  **** 				} else {
 997:stk500boot.c  **** 					fuseBits = boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
 1584               		.loc 1 997 0
 1585 03fc E3E0      		ldi r30,lo8(3)
 1586 03fe F0E0      		ldi r31,0
 1587               	.L190:
 1588 0400 89E0      		ldi r24,lo8(9)
 1589               	.L191:
 1590               	/* #APP */
 1591               	 ;  997 "stk500boot.c" 1
 1592 0402 8093 5700 		sts 87, r24
 1593 0406 8491      		lpm r24, Z
 1594               		
 1595               	 ;  0 "" 2
 1596               	.LVL127:
 1597               	/* #NOAPP */
 1598               	.L196:
 1599               	.LBE78:
 998:stk500boot.c  **** 				}
 999:stk500boot.c  **** 				msgLength = 4;
1000:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1600               		.loc 1 1000 0
 1601 0408 1A82      		std Y+2,__zero_reg__
1001:stk500boot.c  **** 				msgBuffer[2] = fuseBits;
 1602               		.loc 1 1001 0
 1603 040a 8B83      		std Y+3,r24
 1604 040c 00C0      		rjmp .L194
 1605               	.LVL128:
 1606               	.L103:
 1607               	.LBE75:
 1608               	.LBB79:
1002:stk500boot.c  **** 				msgBuffer[3] = STATUS_CMD_OK;
1003:stk500boot.c  **** 			}
1004:stk500boot.c  **** 				break;
1005:stk500boot.c  **** 
1006:stk500boot.c  **** #ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
1007:stk500boot.c  **** 			case CMD_PROGRAM_LOCK_ISP: {
1008:stk500boot.c  **** 				unsigned char lockBits = msgBuffer[4];
1009:stk500boot.c  **** 
1010:stk500boot.c  **** 				lockBits = (~lockBits) & 0x3C; // mask BLBxx bits
 1609               		.loc 1 1010 0
 1610 040e 8D81      		ldd r24,Y+5
 1611               	.LVL129:
 1612               	.LBB80:
1011:stk500boot.c  **** 				boot_lock_bits_set(lockBits);
 1613               		.loc 1 1011 0
 1614 0410 836C      		ori r24,lo8(-61)
 1615               	.LVL130:
 1616 0412 99E0      		ldi r25,lo8(9)
 1617               	.LVL131:
 1618               	/* #APP */
 1619               	 ;  1011 "stk500boot.c" 1
 1620 0414 E1E0      		ldi r30, 1
 1621 0416 F0E0      		ldi r31, 0
 1622 0418 082E      		mov r0, r24
 1623 041a 9093 5700 		sts 87, r25
 1624 041e E895      		spm
 1625               		
 1626               	 ;  0 "" 2
 1627               	/* #NOAPP */
 1628               	.L116:
 1629               	.LBE80:
1012:stk500boot.c  **** 				// and program it
1013:stk500boot.c  **** 				boot_spm_busy_wait();
 1630               		.loc 1 1013 0 discriminator 1
 1631 0420 07B6      		in __tmp_reg__,0x37
 1632 0422 00FC      		sbrc __tmp_reg__,0
 1633 0424 00C0      		rjmp .L116
 1634               	.LVL132:
1014:stk500boot.c  **** 
1015:stk500boot.c  **** 				msgLength = 3;
1016:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1635               		.loc 1 1016 0
 1636 0426 1A82      		std Y+2,__zero_reg__
1017:stk500boot.c  **** 				msgBuffer[2] = STATUS_CMD_OK;
 1637               		.loc 1 1017 0
 1638 0428 1B82      		std Y+3,__zero_reg__
 1639               	.LVL133:
 1640               	.L192:
1015:stk500boot.c  **** 				msgLength = 3;
 1641               		.loc 1 1015 0
 1642 042a 03E0      		ldi r16,lo8(3)
 1643 042c 10E0      		ldi r17,0
 1644               	.LBE79:
1018:stk500boot.c  **** 			}
1019:stk500boot.c  **** 				break;
 1645               		.loc 1 1019 0
 1646 042e 00C0      		rjmp .L109
 1647               	.LVL134:
 1648               	.L98:
1020:stk500boot.c  **** #endif
1021:stk500boot.c  **** 			case CMD_CHIP_ERASE_ISP:
1022:stk500boot.c  **** 				eraseAddress = 0;
1023:stk500boot.c  **** 				msgLength = 2;
1024:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
1025:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_FAILED; //*	isue 543, return FAILED instead of OK
 1649               		.loc 1 1025 0
 1650 0430 80EC      		ldi r24,lo8(-64)
 1651               	.LVL135:
 1652 0432 8A83      		std Y+2,r24
1023:stk500boot.c  **** 				msgLength = 2;
 1653               		.loc 1 1023 0
 1654 0434 02E0      		ldi r16,lo8(2)
 1655 0436 10E0      		ldi r17,0
1022:stk500boot.c  **** 				eraseAddress = 0;
 1656               		.loc 1 1022 0
 1657 0438 C12C      		mov r12,__zero_reg__
 1658 043a D12C      		mov r13,__zero_reg__
 1659 043c 7601      		movw r14,r12
1026:stk500boot.c  **** 				break;
 1660               		.loc 1 1026 0
 1661 043e 00C0      		rjmp .L109
 1662               	.LVL136:
 1663               	.L92:
1027:stk500boot.c  **** 
1028:stk500boot.c  **** 			case CMD_LOAD_ADDRESS:
1029:stk500boot.c  **** #if defined(RAMPZ)
1030:stk500boot.c  **** 				address = ( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBuf
 1664               		.loc 1 1030 0
 1665 0440 8A81      		ldd r24,Y+2
 1666               	.LVL137:
 1667 0442 4B80      		ldd r4,Y+3
 1668               	.LVL138:
 1669 0444 512C      		mov r5,__zero_reg__
 1670 0446 612C      		mov r6,__zero_reg__
 1671 0448 712C      		mov r7,__zero_reg__
 1672 044a 3201      		movw r6,r4
 1673 044c 5524      		clr r5
 1674 044e 4424      		clr r4
 1675 0450 782A      		or r7,r24
 1676 0452 8D81      		ldd r24,Y+5
 1677 0454 482A      		or r4,r24
 1678 0456 8C81      		ldd r24,Y+4
 1679 0458 582A      		or r5,r24
 1680 045a 440C      		lsl r4
 1681 045c 551C      		rol r5
 1682 045e 661C      		rol r6
 1683 0460 771C      		rol r7
 1684               	.L197:
 1685               	.LVL139:
1031:stk500boot.c  **** #else
1032:stk500boot.c  **** 				address = (((msgBuffer[3]) << 8) | (msgBuffer[4])) << 1; //convert word to byte address
1033:stk500boot.c  **** #endif
1034:stk500boot.c  **** 				msgLength = 2;
1035:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1686               		.loc 1 1035 0
 1687 0462 1A82      		std Y+2,__zero_reg__
 1688 0464 00C0      		rjmp .L193
 1689               	.LVL140:
 1690               	.L90:
 1691               	.LBB81:
1036:stk500boot.c  **** 				break;
1037:stk500boot.c  **** 
1038:stk500boot.c  **** 			case CMD_PROGRAM_FLASH_ISP:
1039:stk500boot.c  **** 			case CMD_PROGRAM_EEPROM_ISP: {
1040:stk500boot.c  **** 				unsigned int size = ((msgBuffer[1]) << 8) | msgBuffer[2];
 1692               		.loc 1 1040 0
 1693 0466 2A80      		ldd r2,Y+2
 1694 0468 312C      		mov r3,__zero_reg__
 1695               	.LVL141:
 1696 046a 322C      		mov r3,r2
 1697 046c 2224      		clr r2
 1698               	.LVL142:
 1699 046e 8B81      		ldd r24,Y+3
 1700               	.LVL143:
 1701 0470 282A      		or r2,r24
 1702               	.LVL144:
1041:stk500boot.c  **** 				unsigned char *p = msgBuffer + 10;
1042:stk500boot.c  **** 				unsigned int data;
1043:stk500boot.c  **** 				unsigned char highByte, lowByte;
1044:stk500boot.c  **** 				address_t tempaddress = address;
1045:stk500boot.c  **** 
1046:stk500boot.c  **** 				if (msgBuffer[0] == CMD_PROGRAM_FLASH_ISP) {
 1703               		.loc 1 1046 0
 1704 0472 2331      		cpi r18,lo8(19)
 1705 0474 01F0      		breq .+2
 1706 0476 00C0      		rjmp .L117
1047:stk500boot.c  **** 					// erase only main section (bootloader protection)
1048:stk500boot.c  **** 					if (eraseAddress < APP_END) {
 1707               		.loc 1 1048 0
 1708 0478 C114      		cp r12,__zero_reg__
 1709 047a F0EC      		ldi r31,-64
 1710 047c DF06      		cpc r13,r31
 1711 047e F3E0      		ldi r31,3
 1712 0480 EF06      		cpc r14,r31
 1713 0482 F104      		cpc r15,__zero_reg__
 1714 0484 00F4      		brsh .L118
1049:stk500boot.c  **** 						boot_page_erase(eraseAddress);
 1715               		.loc 1 1049 0
 1716 0486 83E0      		ldi r24,lo8(3)
 1717               	/* #APP */
 1718               	 ;  1049 "stk500boot.c" 1
 1719 0488 F601      		movw r30, r12
 1720 048a E092 5B00 		sts  91, r14
 1721 048e 8093 5700 		sts 87, r24
 1722 0492 E895      		spm
 1723               		
 1724               	 ;  0 "" 2
 1725               	/* #NOAPP */
 1726               	.L120:
1050:stk500boot.c  **** 						// Perform page erase
1051:stk500boot.c  **** 						boot_spm_busy_wait(); // Wait until the memory is erased.
 1727               		.loc 1 1051 0 discriminator 1
 1728 0494 07B6      		in __tmp_reg__,0x37
 1729 0496 00FC      		sbrc __tmp_reg__,0
 1730 0498 00C0      		rjmp .L120
1052:stk500boot.c  **** 						eraseAddress += SPM_PAGESIZE; // point to next page to be erase
 1731               		.loc 1 1052 0
 1732 049a 2FEF      		ldi r18,-1
 1733 049c D21A      		sub r13,r18
 1734 049e E20A      		sbc r14,r18
 1735 04a0 F20A      		sbc r15,r18
 1736               	.LVL145:
 1737               	.L118:
 1738 04a2 2B85      		ldd r18,Y+11
 1739               	.LBE81:
 1740               	.LBB83:
 972:stk500boot.c  **** 					signature = SIGNATURE_BYTES & 0x000000FF;
 1741               		.loc 1 972 0 discriminator 1
 1742 04a4 B301      		movw r22,r6
 1743 04a6 A201      		movw r20,r4
 1744 04a8 CE01      		movw r24,r28
 1745 04aa 0B96      		adiw r24,11
 1746               	.LBE83:
 1747               	.LBB84:
1053:stk500boot.c  **** 					}
1054:stk500boot.c  **** 
1055:stk500boot.c  **** 					/* Write FLASH */
1056:stk500boot.c  **** 					do {
1057:stk500boot.c  **** 						lowByte = *p++;
1058:stk500boot.c  **** 						highByte = *p++;
1059:stk500boot.c  **** 
1060:stk500boot.c  **** 						data = (highByte << 8) | lowByte;
1061:stk500boot.c  **** 						boot_page_fill(address, data);
 1748               		.loc 1 1061 0 discriminator 1
 1749 04ac 11E0      		ldi r17,lo8(1)
 1750               	.LVL146:
 1751               	.L122:
 1752 04ae DC01      		movw r26,r24
 1753 04b0 1296      		adiw r26,2
 1754 04b2 CD01      		movw r24,r26
 1755               	.LVL147:
 1756 04b4 FD01      		movw r30,r26
 1757 04b6 3197      		sbiw r30,1
 1758               	.LVL148:
1060:stk500boot.c  **** 						data = (highByte << 8) | lowByte;
 1759               		.loc 1 1060 0 discriminator 1
 1760 04b8 E081      		ld r30,Z
 1761               	.LVL149:
 1762 04ba 30E0      		ldi r19,0
 1763 04bc 3E2B      		or r19,r30
 1764               		.loc 1 1061 0 discriminator 1
 1765               	/* #APP */
 1766               	 ;  1061 "stk500boot.c" 1
 1767 04be 0901      		movw  r0, r18
 1768 04c0 FA01      		movw r30, r20
 1769 04c2 6093 5B00 		sts 91, r22
 1770 04c6 1093 5700 		sts 87, r17
 1771 04ca E895      		spm
 1772 04cc 1124      		clr  r1
 1773               		
 1774               	 ;  0 "" 2
 1775               	.LVL150:
1062:stk500boot.c  **** 
1063:stk500boot.c  **** 						address = address + 2; // Select next word in memory
 1776               		.loc 1 1063 0 discriminator 1
 1777               	/* #NOAPP */
 1778 04ce 4E5F      		subi r20,-2
 1779 04d0 5F4F      		sbci r21,-1
 1780 04d2 6F4F      		sbci r22,-1
 1781 04d4 7F4F      		sbci r23,-1
 1782               	.LVL151:
1064:stk500boot.c  **** 						size -= 2; // Reduce number of bytes to write by two
 1783               		.loc 1 1064 0 discriminator 1
 1784 04d6 E2E0      		ldi r30,2
 1785 04d8 2E1A      		sub r2,r30
 1786 04da 3108      		sbc r3,__zero_reg__
 1787               	.LVL152:
1065:stk500boot.c  **** 					} while (size); // Loop until all bytes written
 1788               		.loc 1 1065 0 discriminator 1
 1789 04dc 2114      		cp r2,__zero_reg__
 1790 04de 3104      		cpc r3,__zero_reg__
 1791 04e0 01F0      		breq .L121
1058:stk500boot.c  **** 						highByte = *p++;
 1792               		.loc 1 1058 0
 1793 04e2 2C91      		ld r18,X
 1794               	.LVL153:
 1795 04e4 00C0      		rjmp .L122
 1796               	.LVL154:
 1797               	.L121:
1066:stk500boot.c  **** 
1067:stk500boot.c  **** 					boot_page_write(tempaddress);
 1798               		.loc 1 1067 0
 1799 04e6 85E0      		ldi r24,lo8(5)
 1800 04e8 882E      		mov r8,r24
 1801               	.LVL155:
 1802               	/* #APP */
 1803               	 ;  1067 "stk500boot.c" 1
 1804 04ea F201      		movw r30, r4
 1805 04ec 6092 5B00 		sts 91, r6
 1806 04f0 8092 5700 		sts 87, r8
 1807 04f4 E895      		spm
 1808               		
 1809               	 ;  0 "" 2
 1810               	/* #NOAPP */
 1811               	.L124:
1068:stk500boot.c  **** 					boot_spm_busy_wait();
 1812               		.loc 1 1068 0 discriminator 1
 1813 04f6 07B6      		in __tmp_reg__,0x37
 1814 04f8 00FC      		sbrc __tmp_reg__,0
 1815 04fa 00C0      		rjmp .L124
1069:stk500boot.c  **** 					boot_rww_enable(); // Re-enable the RWW section
 1816               		.loc 1 1069 0
 1817 04fc 81E1      		ldi r24,lo8(17)
 1818               	/* #APP */
 1819               	 ;  1069 "stk500boot.c" 1
 1820 04fe 8093 5700 		sts 87, r24
 1821 0502 E895      		spm
 1822               		
 1823               	 ;  0 "" 2
 1824               	/* #NOAPP */
 1825 0504 00C0      		rjmp .L125
 1826               	.LVL156:
 1827               	.L117:
 1828               	.LBB82:
1070:stk500boot.c  **** 				} else {
1071:stk500boot.c  **** 					//*	issue 543, this should work, It has not been tested.
1072:stk500boot.c  **** 					uint16_t ii = address >> 1;
 1829               		.loc 1 1072 0
 1830 0506 B301      		movw r22,r6
 1831 0508 A201      		movw r20,r4
 1832 050a 7695      		lsr r23
 1833 050c 6795      		ror r22
 1834 050e 5795      		ror r21
 1835 0510 4795      		ror r20
 1836 0512 CC5D      		subi r28,lo8(-292)
 1837 0514 DE4F      		sbci r29,hi8(-292)
 1838 0516 4883      		st Y,r20
 1839 0518 5983      		std Y+1,r21
 1840 051a 6A83      		std Y+2,r22
 1841 051c 7B83      		std Y+3,r23
 1842 051e C452      		subi r28,lo8(292)
 1843 0520 D140      		sbci r29,hi8(292)
 1844               	.LVL157:
 1845 0522 8E01      		movw r16,r28
 1846 0524 055F      		subi r16,-11
 1847 0526 1F4F      		sbci r17,-1
1073:stk500boot.c  **** 					/* write EEPROM */
1074:stk500boot.c  **** 					while (size) {
 1848               		.loc 1 1074 0
 1849 0528 A12C      		mov r10,__zero_reg__
 1850 052a B12C      		mov r11,__zero_reg__
 1851               	.LVL158:
 1852               	.L126:
 1853               		.loc 1 1074 0 is_stmt 0 discriminator 1
 1854 052c A214      		cp r10,r2
 1855 052e B304      		cpc r11,r3
 1856 0530 01F0      		breq .L203
1075:stk500boot.c  **** 						eeprom_write_byte((uint8_t*) ii, *p++);
 1857               		.loc 1 1075 0 is_stmt 1
 1858 0532 D801      		movw r26,r16
 1859 0534 6D91      		ld r22,X+
 1860 0536 8D01      		movw r16,r26
 1861 0538 CC5D      		subi r28,lo8(-292)
 1862 053a DE4F      		sbci r29,hi8(-292)
 1863 053c 8881      		ld r24,Y
 1864 053e 9981      		ldd r25,Y+1
 1865 0540 C452      		subi r28,lo8(292)
 1866 0542 D140      		sbci r29,hi8(292)
 1867 0544 8A0D      		add r24,r10
 1868 0546 9B1D      		adc r25,r11
 1869               	.LVL159:
 1870 0548 0E94 0000 		call __eewr_byte_m2560
 1871               	.LVL160:
 1872 054c BFEF      		ldi r27,-1
 1873 054e AB1A      		sub r10,r27
 1874 0550 BB0A      		sbc r11,r27
 1875               	.LVL161:
 1876 0552 00C0      		rjmp .L126
 1877               	.L203:
 1878 0554 A501      		movw r20,r10
 1879 0556 60E0      		ldi r22,0
 1880 0558 70E0      		ldi r23,0
 1881 055a 440F      		lsl r20
 1882 055c 551F      		rol r21
 1883 055e 661F      		rol r22
 1884 0560 771F      		rol r23
 1885 0562 440D      		add r20,r4
 1886 0564 551D      		adc r21,r5
 1887 0566 661D      		adc r22,r6
 1888 0568 771D      		adc r23,r7
 1889               	.LVL162:
 1890               	.L125:
 1891               	.LBE82:
1076:stk500boot.c  **** 						address += 2; // Select next EEPROM byte
1077:stk500boot.c  **** 						ii++;
1078:stk500boot.c  **** 						size--;
1079:stk500boot.c  **** 					}
1080:stk500boot.c  **** 				}
1081:stk500boot.c  **** 				msgLength = 2;
1082:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1892               		.loc 1 1082 0
 1893 056a 1A82      		std Y+2,__zero_reg__
 1894               	.LBE84:
1083:stk500boot.c  **** 			}
1084:stk500boot.c  **** 				break;
 1895               		.loc 1 1084 0
 1896 056c 2A01      		movw r4,r20
 1897 056e 3B01      		movw r6,r22
 1898               	.LVL163:
 1899 0570 00C0      		rjmp .L193
 1900               	.LVL164:
 1901               	.L101:
 1902               	.LBB85:
1085:stk500boot.c  **** 
1086:stk500boot.c  **** 			case CMD_READ_FLASH_ISP:
1087:stk500boot.c  **** 			case CMD_READ_EEPROM_ISP: {
1088:stk500boot.c  **** 				unsigned int size = ((msgBuffer[1]) << 8) | msgBuffer[2];
 1903               		.loc 1 1088 0
 1904 0572 8A81      		ldd r24,Y+2
 1905               	.LVL165:
 1906 0574 90E0      		ldi r25,0
 1907               	.LVL166:
 1908 0576 982F      		mov r25,r24
 1909 0578 8827      		clr r24
 1910 057a 3B81      		ldd r19,Y+3
 1911 057c 832B      		or r24,r19
 1912               	.LVL167:
1089:stk500boot.c  **** 				unsigned char *p = msgBuffer + 1;
1090:stk500boot.c  **** 				msgLength = size + 3;
 1913               		.loc 1 1090 0
 1914 057e 8C01      		movw r16,r24
 1915 0580 0D5F      		subi r16,-3
 1916 0582 1F4F      		sbci r17,-1
 1917               	.LVL168:
1091:stk500boot.c  **** 
1092:stk500boot.c  **** 				*p++ = STATUS_CMD_OK;
 1918               		.loc 1 1092 0
 1919 0584 1A82      		std Y+2,__zero_reg__
1093:stk500boot.c  **** 				if (msgBuffer[0] == CMD_READ_FLASH_ISP) {
 1920               		.loc 1 1093 0
 1921 0586 2431      		cpi r18,lo8(20)
 1922 0588 01F4      		brne .L128
 1923 058a DE01      		movw r26,r28
 1924 058c 1396      		adiw r26,3
 1925               	.LVL169:
 1926               	.L130:
 1927               	.LBB86:
 1928               	.LBB87:
1094:stk500boot.c  **** 					unsigned int data;
1095:stk500boot.c  **** 
1096:stk500boot.c  **** 					// Read FLASH
1097:stk500boot.c  **** 					do {
1098:stk500boot.c  **** 						//#if defined(RAMPZ)
1099:stk500boot.c  **** #if (FLASHEND > 0x10000)
1100:stk500boot.c  **** 						data = pgm_read_word_far(address);
 1929               		.loc 1 1100 0 discriminator 1
 1930               	/* #APP */
 1931               	 ;  1100 "stk500boot.c" 1
 1932 058e 6BBE      		out 59, r6
 1933 0590 F201      		movw r30, r4
 1934 0592 2791      		elpm r18, Z+
 1935 0594 3691      		elpm r19, Z
 1936               		
 1937               	 ;  0 "" 2
 1938               	.LVL170:
 1939               	/* #NOAPP */
 1940               	.LBE87:
1101:stk500boot.c  **** #else
1102:stk500boot.c  **** 						data = pgm_read_word_near(address);
1103:stk500boot.c  **** #endif
1104:stk500boot.c  **** 						*p++ = (unsigned char) data; //LSB
 1941               		.loc 1 1104 0 discriminator 1
 1942 0596 2C93      		st X,r18
 1943 0598 1296      		adiw r26,2
 1944               	.LVL171:
 1945 059a FD01      		movw r30,r26
 1946 059c 3197      		sbiw r30,1
1105:stk500boot.c  **** 						*p++ = (unsigned char) (data >> 8); //MSB
 1947               		.loc 1 1105 0 discriminator 1
 1948 059e 3083      		st Z,r19
1106:stk500boot.c  **** 						address += 2; // Select next word in memory
 1949               		.loc 1 1106 0 discriminator 1
 1950 05a0 E2E0      		ldi r30,2
 1951 05a2 4E0E      		add r4,r30
 1952 05a4 511C      		adc r5,__zero_reg__
 1953 05a6 611C      		adc r6,__zero_reg__
 1954 05a8 711C      		adc r7,__zero_reg__
 1955               	.LVL172:
1107:stk500boot.c  **** 						size -= 2;
 1956               		.loc 1 1107 0 discriminator 1
 1957 05aa 0297      		sbiw r24,2
 1958               	.LVL173:
1108:stk500boot.c  **** 					} while (size);
 1959               		.loc 1 1108 0 discriminator 1
 1960 05ac 0097      		sbiw r24,0
 1961 05ae 01F4      		brne .L130
 1962 05b0 00C0      		rjmp .L129
 1963               	.LVL174:
 1964               	.L128:
 1965 05b2 FE01      		movw r30,r28
 1966 05b4 3396      		adiw r30,3
 1967               	.LBE86:
1093:stk500boot.c  **** 				if (msgBuffer[0] == CMD_READ_FLASH_ISP) {
 1968               		.loc 1 1093 0
 1969 05b6 9C01      		movw r18,r24
 1970 05b8 B301      		movw r22,r6
 1971 05ba A201      		movw r20,r4
 1972               	.LVL175:
 1973               	.L132:
1109:stk500boot.c  **** 				} else {
1110:stk500boot.c  **** 					/* Read EEPROM */
1111:stk500boot.c  **** 					do {
1112:stk500boot.c  **** 						EEARL = address; // Setup EEPROM address
 1974               		.loc 1 1112 0 discriminator 1
 1975 05bc 41BD      		out 0x21,r20
1113:stk500boot.c  **** 						EEARH = ((address >> 8));
 1976               		.loc 1 1113 0 discriminator 1
 1977 05be 852E      		mov r8,r21
 1978 05c0 962E      		mov r9,r22
 1979 05c2 A72E      		mov r10,r23
 1980 05c4 BB24      		clr r11
 1981 05c6 CC5D      		subi r28,lo8(-292)
 1982 05c8 DE4F      		sbci r29,hi8(-292)
 1983 05ca 8882      		st Y,r8
 1984 05cc 9982      		std Y+1,r9
 1985 05ce AA82      		std Y+2,r10
 1986 05d0 BB82      		std Y+3,r11
 1987 05d2 C452      		subi r28,lo8(292)
 1988 05d4 D140      		sbci r29,hi8(292)
 1989 05d6 82BC      		out 0x22,r8
1114:stk500boot.c  **** 						address++; // Select next EEPROM byte
 1990               		.loc 1 1114 0 discriminator 1
 1991 05d8 4F5F      		subi r20,-1
 1992 05da 5F4F      		sbci r21,-1
 1993 05dc 6F4F      		sbci r22,-1
 1994 05de 7F4F      		sbci r23,-1
 1995               	.LVL176:
1115:stk500boot.c  **** 						EECR |= (1 << EERE); // Read EEPROM
 1996               		.loc 1 1115 0 discriminator 1
 1997 05e0 F89A      		sbi 0x1f,0
 1998               	.LVL177:
1116:stk500boot.c  **** 						*p++ = EEDR; // Send EEPROM data
 1999               		.loc 1 1116 0 discriminator 1
 2000 05e2 A0B5      		in r26,0x20
 2001 05e4 A193      		st Z+,r26
 2002               	.LVL178:
1117:stk500boot.c  **** 						size--;
 2003               		.loc 1 1117 0 discriminator 1
 2004 05e6 2150      		subi r18,1
 2005 05e8 3109      		sbc r19,__zero_reg__
 2006               	.LVL179:
1118:stk500boot.c  **** 					} while (size);
 2007               		.loc 1 1118 0 discriminator 1
 2008 05ea 2115      		cp r18,__zero_reg__
 2009 05ec 3105      		cpc r19,__zero_reg__
 2010 05ee 01F4      		brne .L132
 2011 05f0 AC01      		movw r20,r24
 2012               	.LVL180:
 2013 05f2 4150      		subi r20,1
 2014 05f4 5109      		sbc r21,__zero_reg__
 2015 05f6 60E0      		ldi r22,0
 2016 05f8 70E0      		ldi r23,0
 2017 05fa 4F5F      		subi r20,-1
 2018 05fc 5F4F      		sbci r21,-1
 2019 05fe 6F4F      		sbci r22,-1
 2020 0600 7F4F      		sbci r23,-1
 2021 0602 440E      		add r4,r20
 2022 0604 551E      		adc r5,r21
 2023 0606 661E      		adc r6,r22
 2024 0608 771E      		adc r7,r23
 2025 060a A3E0      		ldi r26,lo8(3)
 2026 060c B0E0      		ldi r27,0
 2027 060e AC0F      		add r26,r28
 2028 0610 BD1F      		adc r27,r29
 2029 0612 A80F      		add r26,r24
 2030 0614 B91F      		adc r27,r25
 2031               	.LVL181:
 2032               	.L129:
1119:stk500boot.c  **** 				}
1120:stk500boot.c  **** 				*p++ = STATUS_CMD_OK;
 2033               		.loc 1 1120 0
 2034 0616 1C92      		st X,__zero_reg__
 2035               	.LBE85:
1121:stk500boot.c  **** 			}
1122:stk500boot.c  **** 				break;
 2036               		.loc 1 1122 0
 2037 0618 00C0      		rjmp .L109
 2038               	.LVL182:
 2039               	.L89:
1123:stk500boot.c  **** 
1124:stk500boot.c  **** 			default:
1125:stk500boot.c  **** 				msgLength = 2;
1126:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_FAILED;
 2040               		.loc 1 1126 0
 2041 061a 80EC      		ldi r24,lo8(-64)
 2042               	.LVL183:
 2043 061c 8A83      		std Y+2,r24
 2044               	.LVL184:
 2045               	.L193:
1125:stk500boot.c  **** 				msgLength = 2;
 2046               		.loc 1 1125 0
 2047 061e 02E0      		ldi r16,lo8(2)
 2048 0620 10E0      		ldi r17,0
 2049               	.LVL185:
 2050               	.L109:
1127:stk500boot.c  **** 				break;
1128:stk500boot.c  **** 			}
1129:stk500boot.c  **** 
1130:stk500boot.c  **** 			/*
1131:stk500boot.c  **** 			 * Now send answer message back
1132:stk500boot.c  **** 			 */
1133:stk500boot.c  **** 			sendchar(MESSAGE_START);
 2051               		.loc 1 1133 0
 2052 0622 8BE1      		ldi r24,lo8(27)
 2053 0624 0E94 0000 		call sendchar
 2054               	.LVL186:
1134:stk500boot.c  **** 			checksum = MESSAGE_START ^ 0;
1135:stk500boot.c  **** 
1136:stk500boot.c  **** 			sendchar(seqNum);
 2055               		.loc 1 1136 0
 2056 0628 C05E      		subi r28,lo8(-288)
 2057 062a DE4F      		sbci r29,hi8(-288)
 2058 062c 8881      		ld r24,Y
 2059 062e C052      		subi r28,lo8(288)
 2060 0630 D140      		sbci r29,hi8(288)
 2061 0632 0E94 0000 		call sendchar
 2062               	.LVL187:
1137:stk500boot.c  **** 			checksum ^= seqNum;
1138:stk500boot.c  **** 
1139:stk500boot.c  **** 			c = ((msgLength >> 8) & 0xFF);
1140:stk500boot.c  **** 			sendchar(c);
 2063               		.loc 1 1140 0
 2064 0636 812F      		mov r24,r17
 2065 0638 0E94 0000 		call sendchar
 2066               	.LVL188:
1141:stk500boot.c  **** 			checksum ^= c;
1142:stk500boot.c  **** 
1143:stk500boot.c  **** 			c = msgLength & 0x00FF;
1144:stk500boot.c  **** 			sendchar(c);
 2067               		.loc 1 1144 0
 2068 063c 802F      		mov r24,r16
 2069 063e 0E94 0000 		call sendchar
 2070               	.LVL189:
1145:stk500boot.c  **** 			checksum ^= c;
1146:stk500boot.c  **** 
1147:stk500boot.c  **** 			sendchar(TOKEN);
 2071               		.loc 1 1147 0
 2072 0642 8EE0      		ldi r24,lo8(14)
 2073 0644 0E94 0000 		call sendchar
 2074               	.LVL190:
1141:stk500boot.c  **** 			checksum ^= c;
 2075               		.loc 1 1141 0
 2076 0648 65E1      		ldi r22,lo8(21)
 2077 064a 362E      		mov r3,r22
 2078 064c C05E      		subi r28,lo8(-288)
 2079 064e DE4F      		sbci r29,hi8(-288)
 2080 0650 9880      		ld r9,Y
 2081 0652 C052      		subi r28,lo8(288)
 2082 0654 D140      		sbci r29,hi8(288)
 2083 0656 3924      		eor r3,r9
1145:stk500boot.c  **** 			checksum ^= c;
 2084               		.loc 1 1145 0
 2085 0658 3026      		eor r3,r16
1148:stk500boot.c  **** 			checksum ^= TOKEN;
 2086               		.loc 1 1148 0
 2087 065a 3126      		eor r3,r17
 2088               	.LVL191:
 2089 065c AE01      		movw r20,r28
 2090 065e 4F5F      		subi r20,-1
 2091 0660 5F4F      		sbci r21,-1
 2092 0662 5A01      		movw r10,r20
 2093 0664 040F      		add r16,r20
 2094 0666 151F      		adc r17,r21
 2095               	.LVL192:
 2096               	.L133:
1149:stk500boot.c  **** 
1150:stk500boot.c  **** 			p = msgBuffer;
1151:stk500boot.c  **** 			while (msgLength) {
 2097               		.loc 1 1151 0 discriminator 1
 2098 0668 A016      		cp r10,r16
 2099 066a B106      		cpc r11,r17
 2100 066c 01F0      		breq .L204
 2101               	.LVL193:
1152:stk500boot.c  **** 				c = *p++;
 2102               		.loc 1 1152 0
 2103 066e D501      		movw r26,r10
 2104 0670 2D90      		ld r2,X+
 2105               	.LVL194:
 2106 0672 5D01      		movw r10,r26
 2107               	.LVL195:
1153:stk500boot.c  **** 				sendchar(c);
 2108               		.loc 1 1153 0
 2109 0674 822D      		mov r24,r2
 2110 0676 0E94 0000 		call sendchar
 2111               	.LVL196:
1154:stk500boot.c  **** 				checksum ^= c;
 2112               		.loc 1 1154 0
 2113 067a 3224      		eor r3,r2
 2114               	.LVL197:
 2115 067c 00C0      		rjmp .L133
 2116               	.LVL198:
 2117               	.L204:
1155:stk500boot.c  **** 				msgLength--;
1156:stk500boot.c  **** 			}
1157:stk500boot.c  **** 			sendchar(checksum);
 2118               		.loc 1 1157 0
 2119 067e 832D      		mov r24,r3
 2120 0680 0E94 0000 		call sendchar
 2121               	.LVL199:
1158:stk500boot.c  **** 			seqNum++;
 2122               		.loc 1 1158 0
 2123 0684 C05E      		subi r28,lo8(-288)
 2124 0686 DE4F      		sbci r29,hi8(-288)
 2125 0688 2881      		ld r18,Y
 2126 068a C052      		subi r28,lo8(288)
 2127 068c D140      		sbci r29,hi8(288)
 2128 068e 2F5F      		subi r18,lo8(-(1))
 2129 0690 C05E      		subi r28,lo8(-288)
 2130 0692 DE4F      		sbci r29,hi8(-288)
 2131 0694 2883      		st Y,r18
 2132 0696 C052      		subi r28,lo8(288)
 2133 0698 D140      		sbci r29,hi8(288)
 2134               	.LVL200:
 760:stk500boot.c  **** 		while (!isLeave) {
 2135               		.loc 1 760 0
 2136 069a CF5D      		subi r28,lo8(-289)
 2137 069c DE4F      		sbci r29,hi8(-289)
 2138 069e 4881      		ld r20,Y
 2139 06a0 C152      		subi r28,lo8(289)
 2140 06a2 D140      		sbci r29,hi8(289)
 2141 06a4 4111      		cpse r20,__zero_reg__
 2142 06a6 00C0      		rjmp .L136
 2143 06a8 40E0      		ldi r20,0
 2144 06aa 50E0      		ldi r21,0
 2145 06ac 00C0      		rjmp .L70
 2146               	.LVL201:
 2147               	.L69:
1159:stk500boot.c  **** 
1160:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
1161:stk500boot.c  **** 			//*	<MLS>	toggle the LED
1162:stk500boot.c  **** 		//	PROGLED_PORT ^= (1 << PROGLED_PIN); // active high LED ON
1163:stk500boot.c  **** #endif
1164:stk500boot.c  **** 
1165:stk500boot.c  **** 		}
1166:stk500boot.c  **** 	}
1167:stk500boot.c  **** 
1168:stk500boot.c  **** 	if (boot_state == 2) {
 2148               		.loc 1 1168 0
 2149 06ae 4230      		cpi r20,2
 2150 06b0 5105      		cpc r21,__zero_reg__
 2151 06b2 01F0      		breq .+2
 2152 06b4 00C0      		rjmp .L136
1169:stk500boot.c  **** 		if (eeprom_read_byte(4095) == 0xF0) {
 2153               		.loc 1 1169 0
 2154 06b6 8FEF      		ldi r24,lo8(-1)
 2155 06b8 9FE0      		ldi r25,lo8(15)
 2156               	.LVL202:
 2157 06ba 0E94 0000 		call __eerd_byte_m2560
 2158               	.LVL203:
 2159 06be 803F      		cpi r24,lo8(-16)
 2160 06c0 01F0      		breq .+2
 2161 06c2 00C0      		rjmp .L136
 2162               	.LBB88:
1170:stk500boot.c  **** 			sendchar('u');
 2163               		.loc 1 1170 0
 2164 06c4 85E7      		ldi r24,lo8(117)
 2165 06c6 0E94 0000 		call sendchar
 2166               	.LVL204:
1171:stk500boot.c  **** 			sendchar('p');
 2167               		.loc 1 1171 0
 2168 06ca 80E7      		ldi r24,lo8(112)
 2169 06cc 0E94 0000 		call sendchar
 2170               	.LVL205:
1172:stk500boot.c  **** 			sendchar('g');
 2171               		.loc 1 1172 0
 2172 06d0 87E6      		ldi r24,lo8(103)
 2173 06d2 0E94 0000 		call sendchar
 2174               	.LVL206:
1173:stk500boot.c  **** 			sendchar('r');
 2175               		.loc 1 1173 0
 2176 06d6 82E7      		ldi r24,lo8(114)
 2177 06d8 0E94 0000 		call sendchar
 2178               	.LVL207:
1174:stk500boot.c  **** 			sendchar('a');
 2179               		.loc 1 1174 0
 2180 06dc 81E6      		ldi r24,lo8(97)
 2181 06de 0E94 0000 		call sendchar
 2182               	.LVL208:
1175:stk500boot.c  **** 			sendchar('d');
 2183               		.loc 1 1175 0
 2184 06e2 84E6      		ldi r24,lo8(100)
 2185 06e4 0E94 0000 		call sendchar
 2186               	.LVL209:
1176:stk500boot.c  **** 			sendchar('i');
 2187               		.loc 1 1176 0
 2188 06e8 89E6      		ldi r24,lo8(105)
 2189 06ea 0E94 0000 		call sendchar
 2190               	.LVL210:
1177:stk500boot.c  **** 			sendchar('n');
 2191               		.loc 1 1177 0
 2192 06ee 8EE6      		ldi r24,lo8(110)
 2193 06f0 0E94 0000 		call sendchar
 2194               	.LVL211:
1178:stk500boot.c  **** 			sendchar('g');
 2195               		.loc 1 1178 0
 2196 06f4 87E6      		ldi r24,lo8(103)
 2197 06f6 0E94 0000 		call sendchar
 2198               	.LVL212:
1179:stk500boot.c  **** 			sendchar(0x0d);
 2199               		.loc 1 1179 0
 2200 06fa 8DE0      		ldi r24,lo8(13)
 2201 06fc 0E94 0000 		call sendchar
 2202               	.LVL213:
1180:stk500boot.c  **** 			sendchar(0x0a);
 2203               		.loc 1 1180 0
 2204 0700 8AE0      		ldi r24,lo8(10)
 2205 0702 0E94 0000 		call sendchar
 2206               	.LVL214:
1181:stk500boot.c  **** 			delay_ms(100);
 2207               		.loc 1 1181 0
 2208 0706 84E6      		ldi r24,lo8(100)
 2209 0708 90E0      		ldi r25,0
 2210 070a 0E94 0000 		call delay_ms
 2211               	.LVL215:
1182:stk500boot.c  **** 
1183:stk500boot.c  **** 			DWORD fa; /* Flash address */
1184:stk500boot.c  **** 			sendchar(0x0d);
 2212               		.loc 1 1184 0
 2213 070e 8DE0      		ldi r24,lo8(13)
 2214 0710 0E94 0000 		call sendchar
 2215               	.LVL216:
1185:stk500boot.c  **** 			sendchar(0x0a);
 2216               		.loc 1 1185 0
 2217 0714 8AE0      		ldi r24,lo8(10)
 2218 0716 0E94 0000 		call sendchar
 2219               	.LVL217:
1186:stk500boot.c  **** 			long address = 16;
1187:stk500boot.c  **** 			for (fa = 0; fa < 0x3E000; fa += SPM_PAGESIZE) { /* Update all application pages */
 2220               		.loc 1 1187 0
 2221 071a C12C      		mov r12,__zero_reg__
 2222 071c D12C      		mov r13,__zero_reg__
 2223 071e 7601      		movw r14,r12
 2224               	.LBB89:
1188:stk500boot.c  **** 		//		PROGLED_PORT ^= (1 << PROGLED_PIN); // turn LED ON
1189:stk500boot.c  **** 				delay_ms(50);
1190:stk500boot.c  **** 				flash_erase(fa); /* Erase a page */
1191:stk500boot.c  **** 				memset(Buff, 0xFF, SPM_PAGESIZE); /* Clear buffer */
1192:stk500boot.c  **** 				for (int i = 0; i < SPM_PAGESIZE; i++) {
1193:stk500boot.c  **** 					Buff[i] = spiReadReg(address);
1194:stk500boot.c  **** 					address++;
1195:stk500boot.c  **** 					// sendchar('[');
1196:stk500boot.c  **** 					// dec_hex(Buff[i]);
1197:stk500boot.c  **** 					// sendchar(']');
1198:stk500boot.c  **** 					// if(address % 16 == 0 && address != 0){
1199:stk500boot.c  **** 					// 	sendchar(0x0d);
1200:stk500boot.c  **** 					// 	sendchar(0x0a);
1201:stk500boot.c  **** 					// }
1202:stk500boot.c  **** 					// 
1203:stk500boot.c  **** 					// 
1204:stk500boot.c  **** 					if(((address +1)%1200) <= 300 && ((address +1)%1200) >= 0){
 2225               		.loc 1 1204 0
 2226 0720 50EB      		ldi r21,lo8(-80)
 2227 0722 452E      		mov r4,r21
 2228 0724 54E0      		ldi r21,lo8(4)
 2229 0726 552E      		mov r5,r21
 2230 0728 612C      		mov r6,__zero_reg__
 2231 072a 712C      		mov r7,__zero_reg__
 2232               	.LVL218:
 2233               	.L145:
 2234 072c 4601      		movw r8,r12
 2235 072e 5701      		movw r10,r14
 2236 0730 50E1      		ldi r21,16
 2237 0732 850E      		add r8,r21
 2238 0734 911C      		adc r9,__zero_reg__
 2239 0736 A11C      		adc r10,__zero_reg__
 2240 0738 B11C      		adc r11,__zero_reg__
 2241               	.LVL219:
 2242               	.LBE89:
1189:stk500boot.c  **** 				delay_ms(50);
 2243               		.loc 1 1189 0
 2244 073a 82E3      		ldi r24,lo8(50)
 2245 073c 90E0      		ldi r25,0
 2246 073e 0E94 0000 		call delay_ms
 2247               	.LVL220:
1190:stk500boot.c  **** 				flash_erase(fa); /* Erase a page */
 2248               		.loc 1 1190 0
 2249 0742 C701      		movw r24,r14
 2250 0744 B601      		movw r22,r12
 2251 0746 0E94 0000 		call flash_erase
 2252               	.LVL221:
1191:stk500boot.c  **** 				memset(Buff, 0xFF, SPM_PAGESIZE); /* Clear buffer */
 2253               		.loc 1 1191 0
 2254 074a 40E0      		ldi r20,0
 2255 074c 51E0      		ldi r21,lo8(1)
 2256 074e 6FEF      		ldi r22,lo8(-1)
 2257 0750 70E0      		ldi r23,0
 2258 0752 80E0      		ldi r24,lo8(Buff)
 2259 0754 90E0      		ldi r25,hi8(Buff)
 2260 0756 0E94 0000 		call memset
 2261               	.LVL222:
 2262 075a 00E0      		ldi r16,lo8(Buff)
 2263 075c 10E0      		ldi r17,hi8(Buff)
 2264               	.LVL223:
 2265               	.L143:
 2266               	.LBB90:
1193:stk500boot.c  **** 					Buff[i] = spiReadReg(address);
 2267               		.loc 1 1193 0
 2268 075e C501      		movw r24,r10
 2269 0760 B401      		movw r22,r8
 2270 0762 0E94 0000 		call spiReadReg
 2271               	.LVL224:
 2272 0766 D801      		movw r26,r16
 2273 0768 8D93      		st X+,r24
 2274 076a 8D01      		movw r16,r26
 2275               	.LVL225:
1194:stk500boot.c  **** 					address++;
 2276               		.loc 1 1194 0
 2277 076c BFEF      		ldi r27,-1
 2278 076e 8B1A      		sub r8,r27
 2279 0770 9B0A      		sbc r9,r27
 2280 0772 AB0A      		sbc r10,r27
 2281 0774 BB0A      		sbc r11,r27
 2282               	.LVL226:
 2283 0776 C501      		movw r24,r10
 2284 0778 B401      		movw r22,r8
 2285 077a 6F5F      		subi r22,-1
 2286 077c 7F4F      		sbci r23,-1
 2287 077e 8F4F      		sbci r24,-1
 2288 0780 9F4F      		sbci r25,-1
 2289               		.loc 1 1204 0
 2290 0782 A301      		movw r20,r6
 2291 0784 9201      		movw r18,r4
 2292 0786 0E94 0000 		call __divmodsi4
 2293 078a 6D32      		cpi r22,45
 2294 078c E1E0      		ldi r30,1
 2295 078e 7E07      		cpc r23,r30
 2296 0790 8105      		cpc r24,__zero_reg__
 2297 0792 9105      		cpc r25,__zero_reg__
 2298 0794 00F4      		brsh .L139
1205:stk500boot.c  **** 						LED1_HIGH();
 2299               		.loc 1 1205 0
 2300 0796 109A      		sbi 0x2,0
1206:stk500boot.c  **** 						LED2_LOW();
 2301               		.loc 1 1206 0
 2302 0798 1198      		cbi 0x2,1
 2303 079a 00C0      		rjmp .L195
 2304               	.L139:
1207:stk500boot.c  **** 						LED3_LOW();
1208:stk500boot.c  **** 					}else if(((address +1)%1200) <= 700 && ((address +1)%1200) >= 400){
 2305               		.loc 1 1208 0
 2306 079c 9B01      		movw r18,r22
 2307 079e AC01      		movw r20,r24
 2308 07a0 2059      		subi r18,-112
 2309 07a2 3140      		sbci r19,1
 2310 07a4 4109      		sbc r20,__zero_reg__
 2311 07a6 5109      		sbc r21,__zero_reg__
 2312 07a8 2D32      		cpi r18,45
 2313 07aa 3140      		sbci r19,1
 2314 07ac 4105      		cpc r20,__zero_reg__
 2315 07ae 5105      		cpc r21,__zero_reg__
 2316 07b0 00F4      		brsh .L141
1209:stk500boot.c  **** 						LED1_LOW();
 2317               		.loc 1 1209 0
 2318 07b2 1098      		cbi 0x2,0
1210:stk500boot.c  **** 						LED2_HIGH();
 2319               		.loc 1 1210 0
 2320 07b4 119A      		sbi 0x2,1
 2321               	.L195:
1211:stk500boot.c  **** 						LED3_LOW();
 2322               		.loc 1 1211 0
 2323 07b6 1298      		cbi 0x2,2
 2324 07b8 00C0      		rjmp .L140
 2325               	.L141:
1212:stk500boot.c  **** 					}else if( ((address +1) %1200) <= 1100  && ((address +1) %1200) >= 8){
 2326               		.loc 1 1212 0
 2327 07ba DC01      		movw r26,r24
 2328 07bc CB01      		movw r24,r22
 2329 07be 0897      		sbiw r24,8
 2330 07c0 A109      		sbc r26,__zero_reg__
 2331 07c2 B109      		sbc r27,__zero_reg__
 2332 07c4 8534      		cpi r24,69
 2333 07c6 9440      		sbci r25,4
 2334 07c8 A105      		cpc r26,__zero_reg__
 2335 07ca B105      		cpc r27,__zero_reg__
 2336 07cc 00F4      		brsh .L140
1213:stk500boot.c  **** 						LED1_LOW();
 2337               		.loc 1 1213 0
 2338 07ce 1098      		cbi 0x2,0
1214:stk500boot.c  **** 						LED2_LOW();
 2339               		.loc 1 1214 0
 2340 07d0 1198      		cbi 0x2,1
1215:stk500boot.c  **** 						LED3_HIGH();
 2341               		.loc 1 1215 0
 2342 07d2 129A      		sbi 0x2,2
 2343               	.L140:
 2344               	.LVL227:
1192:stk500boot.c  **** 				for (int i = 0; i < SPM_PAGESIZE; i++) {
 2345               		.loc 1 1192 0
 2346 07d4 40E0      		ldi r20,hi8(Buff+256)
 2347 07d6 0030      		cpi r16,lo8(Buff+256)
 2348 07d8 1407      		cpc r17,r20
 2349 07da 01F4      		brne .L143
 2350               	.LBE90:
1216:stk500boot.c  **** 					}
1217:stk500boot.c  **** 				}
1218:stk500boot.c  **** 				flash_write(fa, Buff); /* Write it if the data is available */
 2351               		.loc 1 1218 0
 2352 07dc 40E0      		ldi r20,lo8(Buff)
 2353 07de 50E0      		ldi r21,hi8(Buff)
 2354 07e0 C701      		movw r24,r14
 2355 07e2 B601      		movw r22,r12
 2356 07e4 0E94 0000 		call flash_write
 2357               	.LVL228:
1187:stk500boot.c  **** 			for (fa = 0; fa < 0x3E000; fa += SPM_PAGESIZE) { /* Update all application pages */
 2358               		.loc 1 1187 0
 2359 07e8 5FEF      		ldi r21,-1
 2360 07ea D51A      		sub r13,r21
 2361 07ec E50A      		sbc r14,r21
 2362 07ee F50A      		sbc r15,r21
 2363               	.LVL229:
 2364 07f0 C114      		cp r12,__zero_reg__
 2365 07f2 60EE      		ldi r22,-32
 2366 07f4 D606      		cpc r13,r22
 2367 07f6 63E0      		ldi r22,3
 2368 07f8 E606      		cpc r14,r22
 2369 07fa F104      		cpc r15,__zero_reg__
 2370 07fc 01F0      		breq .+2
 2371 07fe 00C0      		rjmp .L145
1219:stk500boot.c  **** 			}
1220:stk500boot.c  **** 			sendchar('d');
 2372               		.loc 1 1220 0
 2373 0800 84E6      		ldi r24,lo8(100)
 2374 0802 0E94 0000 		call sendchar
 2375               	.LVL230:
1221:stk500boot.c  **** 			sendchar(0x0d);
 2376               		.loc 1 1221 0
 2377 0806 8DE0      		ldi r24,lo8(13)
 2378 0808 0E94 0000 		call sendchar
 2379               	.LVL231:
1222:stk500boot.c  **** 			sendchar(0x0a);
 2380               		.loc 1 1222 0
 2381 080c 8AE0      		ldi r24,lo8(10)
 2382 080e 0E94 0000 		call sendchar
 2383               	.LVL232:
1223:stk500boot.c  **** 			check = 0;
 2384               		.loc 1 1223 0
 2385 0812 1092 0000 		sts check,__zero_reg__
1224:stk500boot.c  **** 			eeprom_write_byte(4095, 0x00);
 2386               		.loc 1 1224 0
 2387 0816 60E0      		ldi r22,0
 2388 0818 8FEF      		ldi r24,lo8(-1)
 2389 081a 9FE0      		ldi r25,lo8(15)
 2390 081c 0E94 0000 		call __eewr_byte_m2560
 2391               	.LVL233:
 2392               	.L136:
 2393               	.LBE88:
1225:stk500boot.c  **** 		}
1226:stk500boot.c  **** 
1227:stk500boot.c  **** 		boot_state = 0;
1228:stk500boot.c  **** 	}
1229:stk500boot.c  **** 
1230:stk500boot.c  **** 	asm volatile ("nop");
 2394               		.loc 1 1230 0
 2395               	/* #APP */
 2396               	 ;  1230 "stk500boot.c" 1
 2397 0820 0000      		nop
 2398               	 ;  0 "" 2
1231:stk500boot.c  **** 	// wait until port has changed
1232:stk500boot.c  **** 
1233:stk500boot.c  **** //    // SDCARD BOOTLOADER
1234:stk500boot.c  **** //
1235:stk500boot.c  **** //    WORD fa;	/* Flash address */
1236:stk500boot.c  **** //    WORD br;	/* Bytes read */
1237:stk500boot.c  **** //	uint8_t i = 0;
1238:stk500boot.c  **** //
1239:stk500boot.c  **** //
1240:stk500boot.c  **** //	pf_mount(&Fatfs);	/* Initialize file system */
1241:stk500boot.c  **** //
1242:stk500boot.c  **** //
1243:stk500boot.c  **** //	if (pf_open("app.bin") == FR_OK) {	/* Open application file */
1244:stk500boot.c  **** //        PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1245:stk500boot.c  **** //		
1246:stk500boot.c  **** //        for (fa = 0; fa < 0x1000; fa += SPM_PAGESIZE) {	/* Update all application pages */
1247:stk500boot.c  **** //            memset(Buff, 0xFF, SPM_PAGESIZE);		/* Clear buffer */
1248:stk500boot.c  **** //            pf_read(Buff, SPM_PAGESIZE, &br);		/* Load a page data */
1249:stk500boot.c  **** //            
1250:stk500boot.c  **** //			if (br) {					/* Bytes Read > 0? */
1251:stk500boot.c  **** //            	for (i = br; i < SPM_PAGESIZE; i++)     /* Pad the remaining last page with 0xFF so 
1252:stk500boot.c  **** //                    Buff[i] = 0xFF;
1253:stk500boot.c  **** //                if (pagecmp(fa, Buff)) {
1254:stk500boot.c  **** //                    flash_erase(fa);		/* Erase a page */
1255:stk500boot.c  **** //                    flash_write(fa, Buff);		/* Write it if the data is available */
1256:stk500boot.c  **** //                }
1257:stk500boot.c  **** //            }
1258:stk500boot.c  **** //    	}
1259:stk500boot.c  **** //        PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1260:stk500boot.c  **** //        
1261:stk500boot.c  **** //    }
1262:stk500boot.c  **** //    
1263:stk500boot.c  **** //    if (pgm_read_word(0) != 0xFFFF)		/* Start application if exist */
1264:stk500boot.c  **** //        asm volatile("jmp 0000");
1265:stk500boot.c  **** //    // SD CARD BOOTLOADER
1266:stk500boot.c  **** 
1267:stk500boot.c  **** 	/*
1268:stk500boot.c  **** 	 * Now leave bootloader
1269:stk500boot.c  **** 	 */
1270:stk500boot.c  **** 
1271:stk500boot.c  **** 	UART_STATUS_REG &= 0xfd;
 2399               		.loc 1 1271 0
 2400               	/* #NOAPP */
 2401 0822 8091 C000 		lds r24,192
 2402 0826 8D7F      		andi r24,lo8(-3)
 2403 0828 8093 C000 		sts 192,r24
1272:stk500boot.c  **** 	boot_rww_enable(); // enable application section
 2404               		.loc 1 1272 0
 2405 082c 81E1      		ldi r24,lo8(17)
 2406               	/* #APP */
 2407               	 ;  1272 "stk500boot.c" 1
 2408 082e 8093 5700 		sts 87, r24
 2409 0832 E895      		spm
 2410               		
 2411               	 ;  0 "" 2
1273:stk500boot.c  **** 
1274:stk500boot.c  **** 	asm volatile(
 2412               		.loc 1 1274 0
 2413               	 ;  1274 "stk500boot.c" 1
 2414 0834 EE27      		clr	r30		
 2415 0836 FF27      		clr	r31		
 2416 0838 0994      		ijmp	
 2417               		
 2418               	 ;  0 "" 2
 2419               	/* #NOAPP */
 2420               	.L146:
 2421 083a 00C0      		rjmp .L146
 2422               	.LVL234:
 2423               	.L202:
 799:stk500boot.c  **** 						checksum = MESSAGE_START ^ 0;
 2424               		.loc 1 799 0
 2425 083c 4BE1      		ldi r20,lo8(27)
 2426 083e 342E      		mov r3,r20
 2427               	.LVL235:
 798:stk500boot.c  **** 						msgParseState = ST_GET_SEQ_NUM;
 2428               		.loc 1 798 0
 2429 0840 81E0      		ldi r24,lo8(1)
 2430               	.LVL236:
 2431 0842 00C0      		rjmp .L88
 2432               	.LVL237:
 2433               	.L152:
 840:stk500boot.c  **** 						msgParseState = ST_START;
 2434               		.loc 1 840 0
 2435 0844 80E0      		ldi r24,0
 2436               	.LVL238:
 2437 0846 00C0      		rjmp .L88
 2438               	.LVL239:
 2439               	.L153:
 2440 0848 C25E      		subi r28,lo8(-286)
 2441 084a DE4F      		sbci r29,hi8(-286)
 2442 084c 3983      		std Y+1,r19
 2443 084e 2883      		st Y,r18
 2444 0850 CE51      		subi r28,lo8(286)
 2445 0852 D140      		sbci r29,hi8(286)
 848:stk500boot.c  **** 						msgParseState = ST_GET_CHECK;
 2446               		.loc 1 848 0
 2447 0854 86E0      		ldi r24,lo8(6)
 2448               	.LVL240:
 2449 0856 00C0      		rjmp .L88
 2450               		.cfi_endproc
 2451               	.LFE25:
 2453               		.text
 2454               	.global	PrintFromPROGMEM
 2456               	PrintFromPROGMEM:
 2457               	.LFB26:
1275:stk500boot.c  **** 			"clr	r30		\n\t"
1276:stk500boot.c  **** 			"clr	r31		\n\t"
1277:stk500boot.c  **** 			"ijmp	\n\t"
1278:stk500boot.c  **** 	);
1279:stk500boot.c  **** //	asm volatile ( "push r1" "\n\t"		// Jump to Reset vector in Application Section
1280:stk500boot.c  **** //					"push r1" "\n\t"
1281:stk500boot.c  **** //					"ret"	 "\n\t"
1282:stk500boot.c  **** //					::);
1283:stk500boot.c  **** 
1284:stk500boot.c  **** 	/*
1285:stk500boot.c  **** 	 * Never return to stop GCC to generate exit return code
1286:stk500boot.c  **** 	 * Actually we will never reach this point, but the compiler doesn't
1287:stk500boot.c  **** 	 * understand this
1288:stk500boot.c  **** 	 */
1289:stk500boot.c  **** 	for (;;)
1290:stk500boot.c  **** 		;
1291:stk500boot.c  **** }
1292:stk500boot.c  **** 
1293:stk500boot.c  **** /*
1294:stk500boot.c  ****  base address = f800
1295:stk500boot.c  **** 
1296:stk500boot.c  ****  avrdude: Device signature = 0x1e9703
1297:stk500boot.c  ****  avrdude: safemode: lfuse reads as FF
1298:stk500boot.c  ****  avrdude: safemode: hfuse reads as DA
1299:stk500boot.c  ****  avrdude: safemode: efuse reads as F5
1300:stk500boot.c  ****  avrdude>
1301:stk500boot.c  **** 
1302:stk500boot.c  **** 
1303:stk500boot.c  ****  base address = f000
1304:stk500boot.c  ****  avrdude: Device signature = 0x1e9703
1305:stk500boot.c  ****  avrdude: safemode: lfuse reads as FF
1306:stk500boot.c  ****  avrdude: safemode: hfuse reads as D8
1307:stk500boot.c  ****  avrdude: safemode: efuse reads as F5
1308:stk500boot.c  ****  avrdude>
1309:stk500boot.c  ****  */
1310:stk500boot.c  **** 
1311:stk500boot.c  **** //************************************************************************
1312:stk500boot.c  **** #ifdef ENABLE_MONITOR
1313:stk500boot.c  **** #include	<math.h>
1314:stk500boot.c  **** 
1315:stk500boot.c  **** unsigned long gRamIndex;
1316:stk500boot.c  **** unsigned long gFlashIndex;
1317:stk500boot.c  **** unsigned long gEepromIndex;
1318:stk500boot.c  **** 
1319:stk500boot.c  **** #define	true	1
1320:stk500boot.c  **** #define	false	0
1321:stk500boot.c  **** 
1322:stk500boot.c  **** #include	"avr_cpunames.h"
1323:stk500boot.c  **** 
1324:stk500boot.c  **** #ifndef _AVR_CPU_NAME_
1325:stk500boot.c  **** #error cpu name not defined
1326:stk500boot.c  **** #endif
1327:stk500boot.c  **** 
1328:stk500boot.c  **** #ifdef _VECTORS_SIZE
1329:stk500boot.c  **** #define	kInterruptVectorCount (_VECTORS_SIZE / 4)
1330:stk500boot.c  **** #else
1331:stk500boot.c  **** #define	kInterruptVectorCount 23
1332:stk500boot.c  **** #endif
1333:stk500boot.c  **** 
1334:stk500boot.c  **** void PrintDecInt(int theNumber, int digitCnt);
1335:stk500boot.c  **** 
1336:stk500boot.c  **** #ifdef _AVR_CPU_NAME_
1337:stk500boot.c  **** const char gTextMsg_CPU_Name[] PROGMEM = _AVR_CPU_NAME_;
1338:stk500boot.c  **** #else
1339:stk500boot.c  **** const char gTextMsg_CPU_Name[] PROGMEM = "UNKNOWN";
1340:stk500boot.c  **** #endif
1341:stk500boot.c  **** 
1342:stk500boot.c  **** //************************************************************************
1343:stk500boot.c  **** void PrintFromPROGMEM(const void *dataPtr, unsigned char offset)
1344:stk500boot.c  **** {
 2458               		.loc 1 1344 0
 2459               		.cfi_startproc
 2460               	.LVL241:
 2461 0286 CF93      		push r28
 2462               	.LCFI20:
 2463               		.cfi_def_cfa_offset 4
 2464               		.cfi_offset 28, -3
 2465 0288 DF93      		push r29
 2466               	.LCFI21:
 2467               		.cfi_def_cfa_offset 5
 2468               		.cfi_offset 29, -4
 2469               	/* prologue: function */
 2470               	/* frame size = 0 */
 2471               	/* stack size = 2 */
 2472               	.L__stack_usage = 2
1345:stk500boot.c  **** 	char theChar;
1346:stk500boot.c  **** 
1347:stk500boot.c  **** 	dataPtr += offset;
 2473               		.loc 1 1347 0
 2474 028a EC01      		movw r28,r24
 2475 028c C60F      		add r28,r22
 2476 028e D11D      		adc r29,__zero_reg__
 2477               	.LVL242:
 2478               	.L207:
 2479               	.LBB91:
1348:stk500boot.c  **** 
1349:stk500boot.c  **** 	do {
1350:stk500boot.c  **** #if (FLASHEND > 0x10000)
1351:stk500boot.c  **** 		theChar = pgm_read_byte_far((uint16_t)dataPtr++);
 2480               		.loc 1 1351 0
 2481 0290 AE01      		movw r20,r28
 2482 0292 60E0      		ldi r22,0
 2483 0294 70E0      		ldi r23,0
 2484               	/* #APP */
 2485               	 ;  1351 "stk500boot.c" 1
 2486 0296 6BBF      		out 59, r22
 2487 0298 FA01      		movw r30, r20
 2488 029a 8791      		elpm r24, Z+
 2489               		
 2490               	 ;  0 "" 2
 2491               	.LVL243:
 2492               	/* #NOAPP */
 2493               	.LBE91:
1352:stk500boot.c  **** #else
1353:stk500boot.c  **** 		theChar = pgm_read_byte_near((uint16_t)dataPtr++);
1354:stk500boot.c  **** #endif
1355:stk500boot.c  **** 		if (theChar != 0)
 2494               		.loc 1 1355 0
 2495 029c 8823      		tst r24
 2496 029e 01F0      		breq .L205
 2497               	.LVL244:
 2498               	.LBB92:
1351:stk500boot.c  **** 		theChar = pgm_read_byte_far((uint16_t)dataPtr++);
 2499               		.loc 1 1351 0
 2500 02a0 2196      		adiw r28,1
 2501               	.LVL245:
 2502               	.LBE92:
1356:stk500boot.c  **** 		{
1357:stk500boot.c  **** 			sendchar(theChar);
 2503               		.loc 1 1357 0
 2504 02a2 0E94 0000 		call sendchar
 2505               	.LVL246:
 2506 02a6 00C0      		rjmp .L207
 2507               	.LVL247:
 2508               	.L205:
 2509               	/* epilogue start */
1358:stk500boot.c  **** 		}
1359:stk500boot.c  **** 	}while (theChar != 0);
1360:stk500boot.c  **** }
 2510               		.loc 1 1360 0
 2511 02a8 DF91      		pop r29
 2512 02aa CF91      		pop r28
 2513 02ac 0895      		ret
 2514               		.cfi_endproc
 2515               	.LFE26:
 2517               	.global	PrintNewLine
 2519               	PrintNewLine:
 2520               	.LFB27:
1361:stk500boot.c  **** 
1362:stk500boot.c  **** //************************************************************************
1363:stk500boot.c  **** void PrintNewLine(void)
1364:stk500boot.c  **** {
 2521               		.loc 1 1364 0
 2522               		.cfi_startproc
 2523               	/* prologue: function */
 2524               	/* frame size = 0 */
 2525               	/* stack size = 0 */
 2526               	.L__stack_usage = 0
1365:stk500boot.c  **** 	sendchar(0x0d);
 2527               		.loc 1 1365 0
 2528 02ae 8DE0      		ldi r24,lo8(13)
 2529 02b0 0E94 0000 		call sendchar
 2530               	.LVL248:
1366:stk500boot.c  **** 	sendchar(0x0a);
 2531               		.loc 1 1366 0
 2532 02b4 8AE0      		ldi r24,lo8(10)
 2533 02b6 0C94 0000 		jmp sendchar
 2534               	.LVL249:
 2535               		.cfi_endproc
 2536               	.LFE27:
 2538               	.global	PrintFromPROGMEMln
 2540               	PrintFromPROGMEMln:
 2541               	.LFB28:
1367:stk500boot.c  **** }
1368:stk500boot.c  **** 
1369:stk500boot.c  **** //************************************************************************
1370:stk500boot.c  **** void PrintFromPROGMEMln(const void *dataPtr, unsigned char offset)
1371:stk500boot.c  **** {
 2542               		.loc 1 1371 0
 2543               		.cfi_startproc
 2544               	.LVL250:
 2545               	/* prologue: function */
 2546               	/* frame size = 0 */
 2547               	/* stack size = 0 */
 2548               	.L__stack_usage = 0
1372:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
 2549               		.loc 1 1372 0
 2550 02ba 0E94 0000 		call PrintFromPROGMEM
 2551               	.LVL251:
1373:stk500boot.c  **** 
1374:stk500boot.c  **** 	PrintNewLine();
 2552               		.loc 1 1374 0
 2553 02be 0C94 0000 		jmp PrintNewLine
 2554               	.LVL252:
 2555               		.cfi_endproc
 2556               	.LFE28:
 2558               	.global	PrintString
 2560               	PrintString:
 2561               	.LFB29:
1375:stk500boot.c  **** }
1376:stk500boot.c  **** 
1377:stk500boot.c  **** //************************************************************************
1378:stk500boot.c  **** void PrintString(char *textString)
1379:stk500boot.c  **** {
 2562               		.loc 1 1379 0
 2563               		.cfi_startproc
 2564               	.LVL253:
 2565 02c2 CF93      		push r28
 2566               	.LCFI22:
 2567               		.cfi_def_cfa_offset 4
 2568               		.cfi_offset 28, -3
 2569 02c4 DF93      		push r29
 2570               	.LCFI23:
 2571               		.cfi_def_cfa_offset 5
 2572               		.cfi_offset 29, -4
 2573               	/* prologue: function */
 2574               	/* frame size = 0 */
 2575               	/* stack size = 2 */
 2576               	.L__stack_usage = 2
 2577 02c6 EC01      		movw r28,r24
 2578               	.LVL254:
 2579               	.L212:
1380:stk500boot.c  **** 	char theChar;
1381:stk500boot.c  **** 	int ii;
1382:stk500boot.c  **** 
1383:stk500boot.c  **** 	theChar = 1;
1384:stk500boot.c  **** 	ii = 0;
1385:stk500boot.c  **** 	while (theChar != 0)
1386:stk500boot.c  **** 	{
1387:stk500boot.c  **** 		theChar = textString[ii];
 2580               		.loc 1 1387 0
 2581 02c8 8991      		ld r24,Y+
 2582               	.LVL255:
1388:stk500boot.c  **** 		if (theChar != 0)
 2583               		.loc 1 1388 0
 2584 02ca 8823      		tst r24
 2585 02cc 01F0      		breq .L210
1389:stk500boot.c  **** 		{
1390:stk500boot.c  **** 			sendchar(theChar);
 2586               		.loc 1 1390 0
 2587 02ce 0E94 0000 		call sendchar
 2588               	.LVL256:
 2589 02d2 00C0      		rjmp .L212
 2590               	.LVL257:
 2591               	.L210:
 2592               	/* epilogue start */
1391:stk500boot.c  **** 		}
1392:stk500boot.c  **** 		ii++;
1393:stk500boot.c  **** 	}
1394:stk500boot.c  **** }
 2593               		.loc 1 1394 0
 2594 02d4 DF91      		pop r29
 2595 02d6 CF91      		pop r28
 2596               	.LVL258:
 2597 02d8 0895      		ret
 2598               		.cfi_endproc
 2599               	.LFE29:
 2601               	.global	PrintHexByte
 2603               	PrintHexByte:
 2604               	.LFB30:
1395:stk500boot.c  **** 
1396:stk500boot.c  **** //************************************************************************
1397:stk500boot.c  **** void PrintHexByte(unsigned char theByte)
1398:stk500boot.c  **** {
 2605               		.loc 1 1398 0
 2606               		.cfi_startproc
 2607               	.LVL259:
 2608 02da CF93      		push r28
 2609               	.LCFI24:
 2610               		.cfi_def_cfa_offset 4
 2611               		.cfi_offset 28, -3
 2612               	/* prologue: function */
 2613               	/* frame size = 0 */
 2614               	/* stack size = 1 */
 2615               	.L__stack_usage = 1
 2616 02dc C82F      		mov r28,r24
1399:stk500boot.c  **** 	char theChar;
1400:stk500boot.c  **** 
1401:stk500boot.c  **** 	theChar = 0x30 + ((theByte >> 4) & 0x0f);
 2617               		.loc 1 1401 0
 2618 02de 8295      		swap r24
 2619               	.LVL260:
 2620 02e0 8F70      		andi r24,lo8(15)
 2621 02e2 90E3      		ldi r25,lo8(48)
 2622 02e4 980F      		add r25,r24
 2623               	.LVL261:
1402:stk500boot.c  **** 	if (theChar > 0x39)
 2624               		.loc 1 1402 0
 2625 02e6 9A33      		cpi r25,lo8(58)
 2626 02e8 00F0      		brlo .L214
1403:stk500boot.c  **** 	{
1404:stk500boot.c  **** 		theChar += 7;
 2627               		.loc 1 1404 0
 2628 02ea 97E3      		ldi r25,lo8(55)
 2629               	.LVL262:
 2630 02ec 980F      		add r25,r24
 2631               	.LVL263:
 2632               	.L214:
1405:stk500boot.c  **** 	}
1406:stk500boot.c  **** 	sendchar(theChar );
 2633               		.loc 1 1406 0
 2634 02ee 892F      		mov r24,r25
 2635 02f0 0E94 0000 		call sendchar
 2636               	.LVL264:
1407:stk500boot.c  **** 
1408:stk500boot.c  **** 	theChar = 0x30 + (theByte & 0x0f);
 2637               		.loc 1 1408 0
 2638 02f4 CF70      		andi r28,lo8(15)
 2639               	.LVL265:
 2640 02f6 80E3      		ldi r24,lo8(48)
 2641 02f8 8C0F      		add r24,r28
 2642               	.LVL266:
1409:stk500boot.c  **** 	if (theChar > 0x39)
 2643               		.loc 1 1409 0
 2644 02fa 8A33      		cpi r24,lo8(58)
 2645 02fc 00F0      		brlo .L215
1410:stk500boot.c  **** 	{
1411:stk500boot.c  **** 		theChar += 7;
 2646               		.loc 1 1411 0
 2647 02fe 87E3      		ldi r24,lo8(55)
 2648               	.LVL267:
 2649 0300 8C0F      		add r24,r28
 2650               	.LVL268:
 2651               	.L215:
 2652               	/* epilogue start */
1412:stk500boot.c  **** 	}
1413:stk500boot.c  **** 	sendchar(theChar );
1414:stk500boot.c  **** }
 2653               		.loc 1 1414 0
 2654 0302 CF91      		pop r28
1413:stk500boot.c  **** 	sendchar(theChar );
 2655               		.loc 1 1413 0
 2656 0304 0C94 0000 		jmp sendchar
 2657               	.LVL269:
 2658               		.cfi_endproc
 2659               	.LFE30:
 2661               	.global	PrintDecInt
 2663               	PrintDecInt:
 2664               	.LFB31:
1415:stk500boot.c  **** 
1416:stk500boot.c  **** //************************************************************************
1417:stk500boot.c  **** void PrintDecInt(int theNumber, int digitCnt)
1418:stk500boot.c  **** {
 2665               		.loc 1 1418 0
 2666               		.cfi_startproc
 2667               	.LVL270:
 2668 0308 0F93      		push r16
 2669               	.LCFI25:
 2670               		.cfi_def_cfa_offset 4
 2671               		.cfi_offset 16, -3
 2672 030a 1F93      		push r17
 2673               	.LCFI26:
 2674               		.cfi_def_cfa_offset 5
 2675               		.cfi_offset 17, -4
 2676 030c CF93      		push r28
 2677               	.LCFI27:
 2678               		.cfi_def_cfa_offset 6
 2679               		.cfi_offset 28, -5
 2680 030e DF93      		push r29
 2681               	.LCFI28:
 2682               		.cfi_def_cfa_offset 7
 2683               		.cfi_offset 29, -6
 2684               	/* prologue: function */
 2685               	/* frame size = 0 */
 2686               	/* stack size = 4 */
 2687               	.L__stack_usage = 4
 2688 0310 EC01      		movw r28,r24
 2689 0312 8B01      		movw r16,r22
 2690               	.LVL271:
1419:stk500boot.c  **** 	int theChar;
1420:stk500boot.c  **** 	int myNumber;
1421:stk500boot.c  **** 
1422:stk500boot.c  **** 	myNumber = theNumber;
1423:stk500boot.c  **** 
1424:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
 2691               		.loc 1 1424 0
 2692 0314 8536      		cpi r24,101
 2693 0316 9105      		cpc r25,__zero_reg__
 2694 0318 04F4      		brge .L217
 2695               		.loc 1 1424 0 is_stmt 0 discriminator 1
 2696 031a 6330      		cpi r22,3
 2697 031c 7105      		cpc r23,__zero_reg__
 2698 031e 04F0      		brlt .L218
 2699               	.L217:
 2700               	.LVL272:
1425:stk500boot.c  **** 	{
1426:stk500boot.c  **** 		theChar = 0x30 + myNumber / 100;
 2701               		.loc 1 1426 0 is_stmt 1
 2702 0320 CE01      		movw r24,r28
 2703               	.LVL273:
 2704 0322 64E6      		ldi r22,lo8(100)
 2705 0324 70E0      		ldi r23,0
 2706               	.LVL274:
 2707 0326 0E94 0000 		call __divmodhi4
 2708               	.LVL275:
1427:stk500boot.c  **** 		sendchar(theChar );
 2709               		.loc 1 1427 0
 2710 032a 80E3      		ldi r24,lo8(48)
 2711 032c 860F      		add r24,r22
 2712 032e 0E94 0000 		call sendchar
 2713               	.LVL276:
 2714               	.L218:
1428:stk500boot.c  **** 	}
1429:stk500boot.c  **** 
1430:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
 2715               		.loc 1 1430 0
 2716 0332 CB30      		cpi r28,11
 2717 0334 D105      		cpc r29,__zero_reg__
 2718 0336 04F4      		brge .L219
 2719               		.loc 1 1430 0 is_stmt 0 discriminator 1
 2720 0338 0230      		cpi r16,2
 2721 033a 1105      		cpc r17,__zero_reg__
 2722 033c 04F0      		brlt .L220
 2723               	.L219:
 2724               	.LVL277:
1431:stk500boot.c  **** 	{
1432:stk500boot.c  **** 		theChar = 0x30 + ((myNumber % 100) / 10 );
 2725               		.loc 1 1432 0 is_stmt 1
 2726 033e CE01      		movw r24,r28
 2727 0340 64E6      		ldi r22,lo8(100)
 2728 0342 70E0      		ldi r23,0
 2729 0344 0E94 0000 		call __divmodhi4
 2730 0348 6AE0      		ldi r22,lo8(10)
 2731 034a 70E0      		ldi r23,0
 2732 034c 0E94 0000 		call __divmodhi4
1433:stk500boot.c  **** 		sendchar(theChar );
 2733               		.loc 1 1433 0
 2734 0350 80E3      		ldi r24,lo8(48)
 2735 0352 860F      		add r24,r22
 2736 0354 0E94 0000 		call sendchar
 2737               	.LVL278:
 2738               	.L220:
1434:stk500boot.c  **** 	}
1435:stk500boot.c  **** 	theChar = 0x30 + (myNumber % 10);
 2739               		.loc 1 1435 0
 2740 0358 CE01      		movw r24,r28
 2741 035a 6AE0      		ldi r22,lo8(10)
 2742 035c 70E0      		ldi r23,0
 2743 035e 0E94 0000 		call __divmodhi4
1436:stk500boot.c  **** 	sendchar(theChar );
 2744               		.loc 1 1436 0
 2745 0362 805D      		subi r24,lo8(-(48))
 2746               	/* epilogue start */
1437:stk500boot.c  **** }
 2747               		.loc 1 1437 0
 2748 0364 DF91      		pop r29
 2749 0366 CF91      		pop r28
 2750               	.LVL279:
 2751 0368 1F91      		pop r17
 2752 036a 0F91      		pop r16
 2753               	.LVL280:
1436:stk500boot.c  **** 	sendchar(theChar );
 2754               		.loc 1 1436 0
 2755 036c 0C94 0000 		jmp sendchar
 2756               	.LVL281:
 2757               		.cfi_endproc
 2758               	.LFE31:
 2760               		.section	.rodata
 2763               	CSWTCH.43:
 2764 0000 0F        		.byte	15
 2765 0001 02        		.byte	2
 2766 0002 0A        		.byte	10
 2767               	.global	gTextMsg_CPU_Name
 2768               		.section	.progmem.data,"a",@progbits
 2771               	gTextMsg_CPU_Name:
 2772 0000 4154 6D65 		.string	"ATmega2560"
 2772      6761 3235 
 2772      3630 00
 2773               		.comm	gEepromIndex,4,1
 2774               		.comm	gFlashIndex,4,1
 2775               		.comm	gRamIndex,4,1
 2776               	.global	check
 2777               		.data
 2780               	check:
 2781 0000 01        		.byte	1
 2782               	.global	app_start
 2783               		.section .bss
 2786               	app_start:
 2787 0000 0000      		.zero	2
 2788               		.comm	Buff,256,1
 2789               		.text
 2790               	.Letext0:
 2791               		.file 3 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
 2792               		.file 4 "/usr/local/CrossPack-AVR-20131216/lib/gcc/avr/4.8.1/include/stddef.h"
 2793               		.file 5 "integer.h"
 2794               		.file 6 "/usr/local/CrossPack-AVR-20131216/avr/include/avr/eeprom.h"
 2795               		.file 7 "/usr/local/CrossPack-AVR-20131216/avr/include/string.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stk500boot.c
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:2      *ABS*:0000003e __SP_H__
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:3      *ABS*:0000003d __SP_L__
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:4      *ABS*:0000003f __SREG__
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:5      *ABS*:0000003b __RAMPZ__
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:7      *ABS*:00000001 __zero_reg__
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:12     .text:00000000 sendchar
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:41     .text:00000018 transfer
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:67     .text:00000024 setDataMode
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:87     .text:0000002e setBitOrder
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:118    .text:00000040 setClockDivider
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:149    .text:0000005c readStatus
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:180    .text:00000072 busy
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:199    .text:0000007a command
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:236    .text:00000090 spiReadReg
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:308    .init9:00000000 __jumpMain
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:319    *ABS*:000021ff __stack
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:713    .text.startup:00000000 main
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:358    .text:000000d6 delay_ms
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:404    .text:000000f4 dec_hex
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:2786   .bss:00000000 app_start
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:2763   .rodata:00000000 CSWTCH.43
                            *COM*:00000100 Buff
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:2780   .data:00000000 check
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:2456   .text:00000286 PrintFromPROGMEM
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:2519   .text:000002ae PrintNewLine
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:2540   .text:000002ba PrintFromPROGMEMln
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:2560   .text:000002c2 PrintString
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:2603   .text:000002da PrintHexByte
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:2663   .text:00000308 PrintDecInt
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//ccfkhrQY.s:2771   .progmem.data:00000000 gTextMsg_CPU_Name
                            *COM*:00000004 gEepromIndex
                            *COM*:00000004 gFlashIndex
                            *COM*:00000004 gRamIndex

UNDEFINED SYMBOLS
__eewr_byte_m2560
__eerd_byte_m2560
flash_erase
memset
__divmodsi4
flash_write
__divmodhi4
__do_copy_data
__do_clear_bss
